{"meta":{"title":"Blog","subtitle":"","description":"","author":"everlasting","url":"https://everlastingblog.top","root":"/"},"pages":[{"title":"所有分类","date":"2026-01-13T10:26:04.110Z","updated":"2026-01-13T10:26:04.110Z","comments":false,"path":"categories/index.html","permalink":"https://everlastingblog.top/categories/index.html","excerpt":"","text":""},{"title":"","date":"2026-01-13T10:25:59.387Z","updated":"2026-01-13T10:25:59.387Z","comments":false,"path":"about/index.html","permalink":"https://everlastingblog.top/about/index.html","excerpt":"","text":"一枚大一计算机新生"},{"title":"","date":"2026-01-13T10:25:52.152Z","updated":"2026-01-13T10:25:52.152Z","comments":false,"path":"404.html","permalink":"https://everlastingblog.top/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"所有标签","date":"2026-01-13T10:26:08.649Z","updated":"2026-01-13T10:26:08.649Z","comments":false,"path":"tags/index.html","permalink":"https://everlastingblog.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Codeforces Round 1072 (Div.3) E题题解","slug":"Codeforces_Round_1072_E","date":"2026-01-12T16:00:00.000Z","updated":"2026-01-13T11:41:53.177Z","comments":true,"path":"2026/01/13/Codeforces_Round_1072_E/","permalink":"https://everlastingblog.top/2026/01/13/Codeforces_Round_1072_E/","excerpt":"题意：","text":"题意： 定义精致数组-$k$为任意相邻两数之差至少为$k$的数组。 给定长度为$n$的排列$p$，对于每一个从$1$到$n - 1$的$k$，找出精致数组-$k$的数量。 思路：题目要求: 寻找相邻差值至少为$k$的数组个数。 这可以转化为：寻找差分数组中某一子段的最小值至少为$k$的数组个数。 这仍然很麻烦。于是我们可以先统计出最小值为$k,k\\in [1, n - 1]$的子段数，最后再做前缀和即可转换为最小值至少为$k$的数组个数。 关于统计最小值为$k$的子段数，我们可以对差分数组中的每一个数进行单独计算： 对于第$i$个差值，我们可以利用两次单调栈统计出第$i$个差值左侧最近的满足$d[l]&lt;&#x3D;d[i]$的$l$和右侧最近的满足$d[r]&lt;d[i]$的$r$，这样即可以求出对于当前的$d[i]$，以$d[i]$为最小值的数组个数：$(i - l + 1 - 1) \\times (r - i + 1 - 1)$，即：$(i - l) \\times (r - i)$。 这样即可不重不漏地统计出所有最小值为$k$的子段数，最后再从$1$到$n$做前缀和即可求出最小值至少为$k$的数组个数。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;using namespace std;using ld = long double;#define int long long#define fi first#define se secondvoid solve ()&#123; int n; cin &gt;&gt; n; vector &lt;int&gt; v(n + 1), d(n + 3); for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; v[i]; d[i] = abs(v[i] - v[i - 1]); &#125; vector &lt;int&gt; al(n + 3, 1), br(n + 3, n + 1); vector &lt;int&gt; stk; for (int i = 2; i &lt;= n; i++) &#123; while (stk.size() &amp;&amp; d[stk.back()] &gt; d[i]) &#123; stk.pop_back(); &#125; if (stk.size()) al[i] = stk.back(); stk.push_back(i); &#125; stk.clear(); for (int i = n; i &gt;= 2; i--) &#123; while (stk.size() &amp;&amp; d[stk.back()] &gt;= d[i]) &#123; stk.pop_back(); &#125; if (stk.size()) br[i] = stk.back(); stk.push_back(i); &#125; vector &lt;int&gt; ans(n + 1, 0); for (int i = 2; i &lt;= n; i++) &#123; ans[d[i]] += (br[i] - i) * (i - al[i]); &#125; for (int i = n - 2; i &gt;= 1; i--) &#123; ans[i] += ans[i + 1]; &#125; for (int i = 1; i &lt; n; i++) &#123; cout &lt;&lt; ans[i] &lt;&lt; &quot; \\n&quot;[i == n - 1]; &#125;&#125; signed main ()&#123; ios::sync_with_stdio(0); cin.tie(0); int _ = 1; cin &gt;&gt; _; while (_--) &#123; solve(); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://everlastingblog.top/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://everlastingblog.top/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"C语言作业答案(下)","slug":"C_homework_part2","date":"2026-01-06T16:00:00.000Z","updated":"2026-01-13T11:41:50.033Z","comments":true,"path":"2026/01/07/C_homework_part2/","permalink":"https://everlastingblog.top/2026/01/07/C_homework_part2/","excerpt":"第六章1逆序输出输入的整数","text":"第六章1逆序输出输入的整数 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;int main ()&#123; int n; scanf(&quot;%d&quot;, &amp;n); int num [n]; for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;num [i]); &#125; int mask = 1; for (int j = n - 1; j &gt;= 0; j--) &#123; if (mask == 1) &#123; printf(&quot;%d&quot;, num [j]); mask = 0; &#125;else &#123; printf(&quot; %d&quot;, num [j]); &#125; &#125; return 0; &#125; 统计各大写字母的个数1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;int main ()&#123; char s[10000]; scanf(&quot;%[^\\n]&quot;, s); int cnt[26] = &#123;0&#125;; for (int i = 0; s[i] != &#x27;\\0&#x27;; i++) &#123; if (s[i] &gt;= &#x27;A&#x27; &amp;&amp; s[i] &lt;= &#x27;Z&#x27;) &#123; cnt[s[i] - &#x27;A&#x27;]++; &#125; &#125; for (int i = 0; i &lt; 26; i++) &#123; printf(&quot;%c(%d)&quot;, &#x27;A&#x27; + i, cnt[i]); if ((i + 1) % 5 == 0) &#123; printf(&quot;\\n&quot;); &#125; &#125; return 0; &#125; 输出斐波那契数列的前n项12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;int main ()&#123; int n; scanf(&quot;%d&quot;, &amp;n); int num [n]; for (int i = 0; i &lt; n; i++) &#123; if (i == 0 || i == 1) &#123; num [i] = 1; &#125;else &#123; num [i] = num [i - 1] + num [i - 2]; &#125; &#125; int mask = 1; for(int j = 0; j &lt; n; j++) &#123; if (mask % 5 == 0) &#123; if (mask == n) &#123; printf(&quot;%10d&quot;, num [j]); &#125;else &#123; printf(&quot;%10d\\n&quot;, num [j]); mask++; &#125; &#125;else &#123; printf(&quot;%10d&quot;, num [j]); mask++; &#125; &#125; return 0; &#125; 约瑟夫问题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;int main()&#123; int n, m, s; scanf(&quot;%d %d %d&quot;, &amp;n, &amp;m, &amp;s); int num[n + 1]; num[0] = 0; for (int i = 1; i &lt;= n; i++) &#123; num[i] = i; &#125; int i = s; int t = n; while (t &gt; 0) &#123; int cnt = 0; while (cnt &lt; m) &#123; if (num[i] != 0) &#123; cnt++; &#125; if (cnt &lt; m) &#123; i++; if (i &gt; n) &#123; i = 1; &#125; &#125; &#125; printf(&quot;%3d&quot;, num[i]); num[i] = 0; t--; do &#123; i++; if (i &gt; n) &#123; i = 1; &#125; &#125;while (num[i] == 0 &amp;&amp; t &gt; 0); &#125; return 0; &#125; 奇数阶幻方问题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;int main ()&#123; int n; scanf(&quot;%d&quot;, &amp;n); int s[n][n]; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; s[i][j] = 0; &#125; &#125; int i = 0; int j = (n - 1) / 2; for (int k = 1; k &lt;= n * n; k++) &#123; s[i][j] = k; int I = i; int J = j; i -= 1; j += 1; if (i &lt; 0) &#123; i = n - 1; &#125; if (j &gt; n - 1) &#123; j = 0; &#125; if (s[i][j] != 0) &#123; i = I + 1; j = J; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; printf(&quot;%4d&quot;, s[i][j]); if (j == n - 1) &#123; printf(&quot;\\n&quot;); &#125; &#125; &#125; return 0;&#125; 统计学生的总分以及各课程的平均分1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;int main ()&#123; int n, m; scanf(&quot;%d %d&quot;, &amp;n, &amp;m); char name[n][100]; int grade[n][m]; int sum[n]; for (int i = 0; i &lt; n; i++) &#123; sum[i] = 0; &#125; for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%s&quot;, name[i]); for (int j = 0; j &lt; m; j++) &#123; scanf(&quot;%d&quot;, &amp;grade[i][j]); sum[i] += grade[i][j]; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; printf(&quot;%-8s&quot;, name[i]); printf(&quot;%6d&quot;, sum[i]); for (int j = 0; j &lt; m; j++) &#123; printf(&quot;%6d&quot;, grade[i][j]); &#125; printf(&quot;\\n&quot;); &#125; double aver[m]; for (int i = 0; i &lt; m; i++) &#123; aver[i] = 0; &#125; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; aver[i] += grade[j][i]; &#125; aver[i] /= n; &#125; printf(&quot;average score:&quot;); for (int i = 0; i &lt; m; i++) &#123; printf(&quot;%6.1f&quot;, aver[i]); &#125; return 0; &#125; 统计学生成绩的最高最低分以及超过平均分的人数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdio.h&gt;int main () &#123; int n; scanf(&quot;%d&quot;, &amp;n); int grade[n]; double aver = 0; for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;grade[i]); aver += grade[i]; &#125; aver /= n; int cnt = 0; for (int i = 0; i &lt; n; i++) &#123; if (grade[i] &gt; aver) &#123; cnt++; &#125; &#125; int min = grade[0]; for (int i = 1; i &lt; n; i++) &#123; if (grade[i] &lt; min) &#123; min = grade[i]; &#125; &#125; int max = grade[0]; for (int i = 1; i &lt; n; i++) &#123; if (grade[i] &gt; max) &#123; max = grade[i]; &#125; &#125; printf(&quot;%d %d %d&quot;, max, min, cnt); return 0;&#125; 进制转换123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;int main ()&#123; char str[100]; int num = 0; int i = 0; char c; while ((c = getchar()) != &#x27;#&#x27;) &#123; if ((c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) || (c &gt;= &#x27;A&#x27; &amp;&amp; c &lt;= &#x27;F&#x27;) || (c &gt;= &#x27;a&#x27; &amp;&amp; c &lt;= &#x27;f&#x27;)) &#123; str[i++] = c; num *= 16; if (c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123; num += c - &#x27;0&#x27;; &#125;else if (c &gt;= &#x27;A&#x27; &amp;&amp; c &lt;= &#x27;F&#x27;) &#123; num += c - &#x27;A&#x27; + 10; &#125;else if (c &gt;= &#x27;a&#x27; &amp;&amp; c &lt;= &#x27;f&#x27;) &#123; num += c - &#x27;a&#x27; + 10; &#125; &#125; &#125; str[i] = &#x27;\\0&#x27;; printf(&quot;String:%s\\n&quot;, str); printf(&quot;number=%d&quot;, num); return 0; &#125; 求最大字符串1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main ()&#123; int n; scanf(&quot;%d&quot;, &amp;n); getchar(); char str[n][100]; for (int i = 0; i &lt; n; i++) &#123; gets(str[i]); &#125; int maxI = 0; for (int i = 1; i &lt; n; i++) &#123; if (strcmp(str[i], str[maxI]) &gt; 0) &#123; maxI = i; &#125; &#125; printf(&quot;%s&quot;, str[maxI]); return 0; &#125; 字符串首尾相连123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;int main() &#123; char str1[101],str2[101]; int i,j; gets(str1); gets(str2); // Here is your code i = 0; while (str1[i] != &#x27;\\0&#x27; &amp;&amp; str1[i] != &#x27;\\n&#x27;) &#123; i++; &#125; str1[i] = &#x27;\\0&#x27;; j = 0; while (str2[j] != &#x27;\\0&#x27; &amp;&amp; str2[j] != &#x27;\\n&#x27;) &#123; j++; &#125; str2[j] = &#x27;\\0&#x27;; for (int k = 0; k &lt; j; k++) &#123; str1[i] = str2[k]; i++; &#125; str1[i] = &#x27;\\0&#x27;; puts(str1); return 0;&#125; 统计各数字出现的次数123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;int main ()&#123; char c; int num[10] = &#123;0&#125;; while (c != &#x27;!&#x27;)&#123; scanf(&quot;%c&quot;, &amp;c); if (c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123; num[c - &#x27;0&#x27;]++; &#125; &#125; for (int i = 0; i &lt; 10; i++) &#123; if (i == 9) &#123; printf(&quot;The character %d appears %d times&quot;, i, num[i]); &#125;else &#123; printf(&quot;The character %d appears %d times\\n&quot;, i, num[i]); &#125; &#125; return 0; &#125; 找出二维数组中的最小元素12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;stdio.h&gt;int main ()&#123; int m, n; scanf(&quot;%d %d&quot;, &amp;m, &amp;n); int a[m][n]; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; scanf(&quot;%d&quot;, &amp;a[i][j]); &#125; &#125; printf(&quot;before:\\n&quot;); for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; printf(&quot;%4d&quot;, a[i][j]); &#125; printf(&quot;\\n&quot;); &#125; printf(&quot;after:\\n&quot;); int min =a[0][0]; int I = 0; int J = 0; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (a[i][j] &lt; min) &#123; min = a[i][j]; I = i; J = j; &#125; &#125; &#125; for (int j = 0; j &lt; n; j++) &#123; int t = a[m - 1][j]; a[m - 1][j] = a[I][j]; a[I][j] = t; &#125; int mask = 0; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; printf(&quot;%4d&quot;, a[i][j]); &#125; if (i != m - 1) &#123; printf(&quot;\\n&quot;); &#125; &#125; return 0;&#125; 矩阵转置1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;stdio.h&gt;int main ()&#123; int n, m; scanf(&quot;%d %d&quot;, &amp;n, &amp;m); int a[n][m]; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; scanf(&quot;%d&quot;, &amp;a[i][j]); &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (j == m - 1) &#123; printf(&quot;%d&quot;, a[i][j]); &#125;else &#123; printf(&quot;%d &quot;, a[i][j]); &#125; &#125; printf(&quot;\\n&quot;); &#125; int b[m][n]; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; b[i][j] = a[j][i]; if (j == n - 1) &#123; printf(&quot;%d&quot;, b[i][j]); &#125;else &#123; printf(&quot;%d &quot;, b[i][j]); &#125; &#125; printf(&quot;\\n&quot;); &#125; return 0; &#125; 二分查找1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;stdio.h&gt;int main ()&#123; int n; scanf(&quot;%d&quot;, &amp;n); int num[n]; for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;num[i]); &#125; int res; scanf(&quot;%d&quot;, &amp;res); int a = 0; int b = n - 1; int mask = 0; while (a &lt;= b) &#123; int mid = a + (b - a) / 2; if (num[mid] == res) &#123; printf(&quot;%d&quot;, mid); mask = 1; break; &#125;else if (num[mid] &lt; res) &#123; a = mid + 1; &#125;else &#123; b = mid - 1; &#125; &#125; if (mask == 0) &#123; printf(&quot;Not found&quot;); &#125; return 0; &#125; 冒泡排序12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;int main ()&#123; int n; scanf(&quot;%d&quot;, &amp;n); int num[100]; for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;num[i]); &#125; for (int i = 0; i &lt; n - 1; i++) &#123; for (int j = 0; j &lt; n - 1 - i; j++) &#123; if (num[j] &gt; num[j + 1]) &#123; int t = num[j]; num[j] = num[j + 1]; num[j + 1] = t; &#125; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; printf(&quot;%d&quot;, num[i]); if (i != n - 1) &#123; printf(&quot; &quot;); &#125; &#125; return 0; &#125; 第六章2大写改小写12345678910111213141516#include &lt;stdio.h&gt;int main ()&#123; char ch; while (scanf(&quot;%c&quot;, &amp;ch) != EOF &amp;&amp; ch != &#x27;\\n&#x27;) &#123; if (ch &gt;= &#x27;A&#x27; &amp;&amp; ch &lt;= &#x27;Z&#x27;) &#123; ch += 32; &#125; putchar(ch); &#125; return 0; &#125; 串比较12345678910111213141516171819202122#include &lt;stdio.h&gt;int main ()&#123; char str1[101]; gets(str1); char str2[101]; gets(str2); int i = 0; while (str1[i] != &#x27;\\0&#x27; &amp;&amp; str2[i] != &#x27;\\0&#x27; &amp;&amp; str1[i] == str2[i]) &#123; i++; &#125; printf(&quot;%d&quot;, str1[i] - str2[i]); return 0;&#125; 串复制123456789101112131415#include &lt;stdio.h&gt;int main() &#123; char str1[101],str2[101]; int i; gets(str1); // Please fill this blank for (i = 0; str1[i] != &#x27;\\0&#x27;; i++) &#123; str2[i] = str1[i]; &#125; str2[i] = &#x27;\\0&#x27;; puts(str2); return 0;&#125; 逆向输出字符串12345678910111213141516171819202122#include &lt;stdio.h&gt;int main () &#123; char str1[101],str2[101]; int i,j; gets(str1); // Please fill this blank int l = 0; while (str1[l] != &#x27;\\0&#x27;) &#123; l++; &#125; for (i = 0, j = l - 1; j &gt;= 0; i++, j--) &#123; str2[i] = str1[j]; &#125; str2[l] = &#x27;\\0&#x27;; puts(str2); return 0;&#125; 对方阵做统计处理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;stdio.h&gt;void Traverse(int n, int s[n][n])&#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; scanf(&quot;%d&quot;, &amp;s[i][j]); &#125; &#125;&#125;int sumD(int n, int s[n][n])&#123; int sum = 0; for (int i = 0; i &lt; n; i++) &#123; sum += s[i][i]; &#125; for (int i = 0; i &lt; n; i++) &#123; sum += s[n - 1 - i][i]; &#125; if (n % 2 != 0) &#123; sum -= s[(n - 1) / 2][(n - 1) / 2]; &#125; return sum; &#125;int multiple(int n, int s[n][n])&#123; int m = 1; for (int i = 0; i &lt; n; i += 2) &#123; m *= s[i][i]; &#125; for (int j = 0; j &lt; n; j += 2) &#123; if ((n - 1 - j) % 2 == 0) &#123; m *= s[n - 1 - j][j]; &#125; &#125; return m; &#125;int main ()&#123; int n; scanf(&quot;%d&quot;, &amp;n); int s[n][n]; Traverse(n, s); printf(&quot;%d %d\\n&quot;, sumD(n, s), multiple(n,s)); int p[n][n]; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; p[j][n - 1 - i] = s[i][j]; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; printf(&quot;%d&quot;, p[i][j]); if (j &lt; n - 1) &#123; printf(&quot; &quot;); &#125; &#125; if (i &lt; n - 1) &#123; printf(&quot;\\n&quot;); &#125; &#125; return 0; &#125; 兔子和狐狸123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;int main () &#123; int n, m; scanf(&quot;%d %d&quot;, &amp;n, &amp;m); int h[n + 1]; for (int i = 0; i &lt;= n; i++) &#123; h[i] = 1; &#125; h[0] = 0; h[1] = 0; int i = 2; int j = 1; int s = 1; while (s &lt;= m * n) &#123; j += i; s += i; i++; if (s &gt; m * n) &#123; break; &#125; if (j &gt; n) &#123; j %= n; if (j == 0) &#123; j = n; &#125; &#125; h[j] = 0; &#125; int mask = 1; for (int i = 0; i &lt;= n; i++) &#123; if (h[i] == 1) &#123; if (mask == 1) &#123; printf(&quot;%d&quot;, i); mask = 0; &#125;else &#123; printf(&quot; %d&quot;, i); &#125; &#125; &#125; if (mask == 1) &#123; printf(&quot;No choice&quot;); &#125; return 0; &#125; 删除字符串中指定字符123456789101112131415161718192021222324#include &lt;stdio.h&gt;int main ()&#123; char str[101]; gets(str); char ch; scanf(&quot;%c&quot;, &amp;ch); int j = 0; for (int i = 0; str[i] != &#x27;\\0&#x27;; i++) &#123; if (str[i] != ch) &#123; str[j++] = str[i]; &#125; &#125; str[j] = &#x27;\\0&#x27;; printf(&quot;%s&quot;, str); return 0;&#125; 奇偶数分开排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;stdio.h&gt;void sorting (int num[], int n) &#123; for (int i = n - 1; i &gt; 0; i--) &#123; int tag = i; for (int j = i - 1; j &gt;= 0; j--) &#123; if (num[tag] &lt; num[j]) &#123; tag = j; &#125; &#125; int t = num[i]; num[i] = num[tag]; num[tag] = t; &#125;&#125;void print (int num[], int n) &#123; int mask = 1; for (int i = 0; i &lt; n; i++) &#123; if (mask == 1) &#123; printf(&quot;%d&quot;, num[i]); mask = 0; &#125;else &#123; printf(&quot; %d&quot;, num[i]); &#125; &#125;&#125;int main ()&#123; int n; scanf(&quot;%d&quot;, &amp;n); int num[n]; for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;num[i]); &#125; int odd[n]; int even[n]; int cnt1 = 0; int cnt2 = 0; for (int i = 0; i &lt; n; i++) &#123; if (num[i] % 2 == 1) &#123; odd[cnt1] = num[i]; cnt1++; &#125;else &#123; even[cnt2] = num[i]; cnt2++; &#125; &#125; sorting(odd, cnt1); sorting(even, cnt2); print(odd, cnt1); printf(&quot; &quot;); print(even, cnt2); return 0; &#125; 选择排序123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;int main ()&#123; int n; scanf(&quot;%d&quot;, &amp;n); int num[n]; for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;num[i]); &#125; for (int i = n - 1; i &gt; 0; i--) &#123; int tag = i; for (int j = i - 1; j &gt;= 0; j--) &#123; if (num[tag] &lt; num[j]) &#123; tag = j; &#125; &#125; int t = num[i]; num[i] = num[tag]; num[tag] = t; &#125; for (int i = 0; i &lt; n; i++) &#123; printf(&quot;%d &quot;, num[i]); &#125; return 0; &#125; 杨辉三角形123456789101112131415161718192021222324#include &lt;stdio.h&gt;int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); int a[31][31] = &#123;0&#125;; // 构造杨辉三角 for (int i = 0; i &lt; n; i++) &#123; a[i][0] = a[i][i] = 1; for (int j = 1; j &lt; i; j++) &#123; a[i][j] = a[i-1][j-1] + a[i-1][j]; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt;= i; j++) &#123; printf(&quot;%10d&quot;, a[i][j]); &#125; printf(&quot;\\n&quot;); &#125; return 0;&#125; 在有序数组中插入一个数12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;int main ()&#123; int n; scanf(&quot;%d&quot;, &amp;n); int num[n + 1]; for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;num[i]); &#125; int m; scanf(&quot;%d&quot;, &amp;m); num[n] = m; for (int i = n - 1; i &gt;= 0; i--) &#123; if (num[i] &gt; num[i + 1]) &#123; int t = num[i + 1]; num[i + 1] = num [i]; num[i] = t; &#125;else &#123; break; &#125; &#125; int mask = 1; for (int i = 0; i &lt;= n; i++) &#123; if (mask == 1) &#123; printf(&quot;%d&quot;, num[i]); mask = 0; &#125;else &#123; printf(&quot; %d&quot;, num[i]); &#125; &#125; return 0; &#125; 筛法求素数1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;int main () &#123; int n; scanf(&quot;%d&quot;, &amp;n); int Prime[n + 1]; for (int i = 2; i &lt;= n; i++) &#123; Prime[i] = 1; &#125; for (int i = 2; i &lt;= n; i++) &#123; if (Prime[i] == 1) &#123; for (int k = i * i; k &lt;= n; k += i) &#123; Prime[k] = 0; &#125; &#125; &#125; int mask = 1; for (int i = 2; i &lt;= n; i++) &#123; if (Prime[i] != 0) &#123; if (mask == 1) &#123; printf(&quot;%d&quot;, i); mask = 0; &#125;else &#123; printf(&quot; %d&quot;, i); &#125; &#125; &#125; return 0; &#125; 最长对称子串12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;int main ()&#123; char s[1001]; gets(s); int length_I = 1; for (int i = 1; s[i] != &#x27;\\0&#x27;; i++) &#123; int length_i = 1; for (int j = 1; s[i + j] == s[i - j] &amp;&amp; i - j &gt;= 0; j++) &#123; length_i += 2; &#125; if (length_i &gt; length_I) &#123; length_I = length_i; &#125; &#125; int length_J = 0; for (int i = 0; s[i] != &#x27;\\0&#x27;; i++) &#123; int length_j = 0; for (int j = 1; s[i + 1 - j] == s[i + j] &amp;&amp; i + 1 - j &gt;= 0; j++) &#123; length_j += 2; &#125; if (length_j &gt; length_J) &#123; length_J = length_j; &#125; &#125; if (length_J &gt; length_I) &#123; printf(&quot;%d&quot;, length_J); &#125;else &#123; printf(&quot;%d&quot;, length_I); &#125; return 0; &#125; 装睡的人1234567891011121314151617#include &lt;stdio.h&gt;int main() &#123; int N; scanf(&quot;%d&quot;, &amp;N); char name[4]; int breath, pulse; for (int i = 0; i &lt; N; i++) &#123; scanf(&quot;%s %d %d&quot;, name, &amp;breath, &amp;pulse); if (breath &lt; 15 || breath &gt; 20 || pulse &lt; 50 || pulse &gt; 70) &#123; printf(&quot;%s\\n&quot;, name); &#125; &#125; return 0;&#125; 第六章3个位数统计12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() &#123; char N[1005]; int count[10] = &#123;0&#125;; scanf(&quot;%s&quot;, N); for (int i = 0; i &lt; strlen(N); i++) &#123; int d = N[i] - &#x27;0&#x27;; count[d]++; &#125; for (int d = 0; d &lt;= 9; d++) &#123; if (count[d] &gt; 0) &#123; printf(&quot;%d:%d\\n&quot;, d, count[d]); &#125; &#125; return 0;&#125; 找出不是两个数组共有的元素12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;stdio.h&gt;void find(int m, int n, int a[m], int b[n], int s[42])&#123; int cnt = 0; for (int i = 0; i &lt; m; i++) &#123; int mask = 0; for (int j = 0; j &lt; n; j++) &#123; if (a[i] == b[j]) &#123; mask = 1; break; &#125; &#125; if (mask == 0) &#123; s[cnt++] = a[i]; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; int mask = 0; for (int j = 0; j &lt; m; j++) &#123; if (b[i] == a[j]) &#123; mask = 1; break; &#125; &#125; if (mask == 0) &#123; s[cnt++] = b[i]; &#125; &#125;&#125;void printing (int a[42])&#123; int s[42]; for (int i = 0; i &lt; 42; i++) &#123; s[i] = -1; &#125; for (int i = 0; i &lt; 42 &amp;&amp; a[i] != -1; i++) &#123; if (s[i] == -1) &#123; printf(&quot;%d &quot;, a[i]); for (int j = i; j &lt; 42 &amp;&amp; a[j] != -1; j++) &#123; if (a[j] == a[i]) &#123; s[j] = 0; &#125; &#125; &#125; &#125; &#125;int main ()&#123; int n; scanf(&quot;%d&quot;, &amp;n); int a[n]; for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); &#125; int m; scanf(&quot;%d&quot;, &amp;m); int b[m]; for (int i = 0; i &lt; m; i++) &#123; scanf(&quot;%d&quot;, &amp;b[i]); &#125; int s[42]; for (int i = 0; i &lt; 42; i++) &#123; s[i] = -1; &#125; find(n, m, a, b, s); printing(s); return 0; &#125; 字符串逆序12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main ()&#123; char a[81]; fgets(a, sizeof(a), stdin); int length = strlen(a); int j = length - 1; int i = 0; while (i &lt; j) &#123; char b = a[i]; a[i] = a[j]; a[j] = b; i++; j--; &#125; printf(&quot;%s&quot;, a); return 0; &#125; 找鞍点123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); int a[6][6]; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; scanf(&quot;%d&quot;, &amp;a[i][j]); &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; int rowMax = a[i][0]; for (int j = 1; j &lt; n; j++) &#123; if (a[i][j] &gt; rowMax) &#123; rowMax = a[i][j]; &#125; &#125; for (int j = 0; j &lt; n; j++) &#123; if (a[i][j] == rowMax) &#123; int colMin = a[0][j]; for (int k = 1; k &lt; n; k++) &#123; if (a[k][j] &lt; colMin) &#123; colMin = a[k][j]; &#125; &#125; if (a[i][j] == colMin) &#123; printf(&quot;%d %d\\n&quot;, i, j); return 0; &#125; &#125; &#125; &#125; printf(&quot;NONE\\n&quot;); return 0;&#125; 求n以内最大的k个素数以及它们的和123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;void findPrime (int n, int Prime[])&#123; for (int i = 2; i &lt;= n; i++) &#123; Prime[i] = 1; &#125; for (int i = 2; i * i &lt;= n; i++) &#123; if (Prime[i] == 1) &#123; for (int k = i * i; k &lt;= n; k += i) &#123; Prime[k] = 0; &#125; &#125; &#125; Prime[0] = 0; Prime[1] = 0;&#125;int main ()&#123; int max, cnt; scanf(&quot;%d %d&quot;, &amp;max, &amp;cnt); int isPrime[10001]; findPrime(max, isPrime); int sum = 0; int mask = 0; for (int i = max; i &gt; 0 &amp;&amp; mask &lt; cnt; i--) &#123; if (isPrime[i] == 1) &#123; sum += i; if (mask == 0) &#123; printf(&quot;%d&quot;, i); &#125;else &#123; printf(&quot;+%d&quot;, i); &#125; mask++; &#125; &#125; printf(&quot;=%d&quot;, sum); return 0;&#125; 1234方阵123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;stdio.h&gt;void printing (int n, int s[n][n])&#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; printf(&quot;%d&quot;, s[i][j]); if (j &lt; n - 1) &#123; printf(&quot; &quot;); &#125; &#125; printf(&quot;\\n&quot;); &#125;&#125;int main ()&#123; int n; scanf(&quot;%d&quot;, &amp;n); int s[n][n]; for (int i = 0; i &lt; n; i++) &#123; s[i][i] = 0; &#125; for (int i = 0; i &lt; n; i++) &#123; s[n - 1 - i][i] = 0; &#125; int cnt = n - 2; int k = cnt; int l = cnt; int J = 1; for (int i = 0; k &gt; 0; i++) &#123; l = k; int j = J; while (l &gt; 0) &#123; s[i][j] = 1; l--; j++; &#125; k -= 2; J += 1; &#125; cnt = n - 2; k = cnt; l = cnt; int I = 1; for (int j = 0; k &gt; 0; j++) &#123; l = k; int i = I; while (l &gt; 0) &#123; s[i][j] = 2; l--; i++; &#125; k -= 2; I += 1; &#125; cnt = n - 2; k = cnt; l = cnt; J = 1; for (int i = n - 1; k &gt; 0; i--) &#123; l = k; int j = J; while (l &gt; 0) &#123; s[i][j] = 3; l--; j++; &#125; k -= 2; J += 1; &#125; cnt = n - 2; k = cnt; l = cnt; I = 1; for (int j = n - 1; k &gt; 0; j--) &#123; l = k; int i = I; while (l &gt; 0) &#123; s[i][j] = 4; l--; i++; &#125; k -= 2; I += 1; &#125; printing(n, s); return 0; &#125; 心情查询1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;stdio.h&gt;void Traverse1 (int n, int s[n])&#123; for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;s[i]); &#125;&#125;void initialize_Traverse2 (int n, int s[n])&#123; for (int i = 0; i &lt; n; i++) &#123; s[i] = -1; &#125; int i = 0; int j; while (i &lt; n - 1 &amp;&amp; scanf(&quot;%d&quot;, &amp;j) == 1) &#123; if (j &lt; 0 || j &gt; 23) &#123; break; &#125;else &#123; s[i++] = j; &#125; &#125;&#125;int main ()&#123; const int n = 24; int s[n]; Traverse1(n, s); int hour[n + 1]; initialize_Traverse2(n + 1, hour); int i = 0; while (i &lt; n + 1 &amp;&amp; hour[i] != -1) &#123; if (s[hour[i]] &gt; 50) &#123; printf(&quot;%d Yes&quot;, s[hour[i]]); &#125;else if (s[hour[i]] &lt;= 50) &#123; printf(&quot;%d No&quot;, s[hour[i]]); &#125; if (s[hour[i + 1]] != -1) &#123; printf(&quot;\\n&quot;); &#125;else &#123; break; &#125; i++; &#125; return 0; &#125; 点赞12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;int main ()&#123; int n; scanf(&quot;%d&quot;, &amp;n); int q[1001] = &#123;0&#125;; for (int i = 0; i &lt; n; i++) &#123; int p; scanf(&quot;%d&quot;, &amp;p); for (int j = 0; j &lt; p; j++) &#123; int k; scanf(&quot;%d&quot;, &amp;k); q[k]++; &#125; &#125; int max = 1000; for (int i = 1000; i &gt;= 0; i--) &#123; if (q[i] &gt; q[max]) &#123; max = i; &#125; &#125; printf(&quot;%d %d&quot;, max, q[max]); return 0;&#125; 古风排版12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdio.h&gt;int ceiling (double num)&#123; int i = (int)num; if (num &gt; i) &#123; return i + 1; &#125; return i;&#125;int main ()&#123; int n; scanf(&quot;%d&quot;, &amp;n); getchar(); char s[1001]; gets(s); int len = 0; while (s[len] != &#x27;\\0&#x27;) &#123; len++; &#125; s[len] = &#x27;\\0&#x27;; int column = ceiling((double)len / n); char c[n][column]; int k = 0; for (int j = column - 1; j &gt;= 0; j--) &#123; for (int i = 0; i &lt; n; i++) &#123; if (k &lt; len) &#123; c[i][j] = s[k++]; &#125; else &#123; c[i][j] = &#x27; &#x27;; &#125; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; column; j++) &#123; printf(&quot;%c&quot;, c[i][j]); &#125; printf(&quot;\\n&quot;); &#125; return 0; &#125; 字符串A-B1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;int main ()&#123; char a[10001]; gets(a); char b[10001]; gets(b); int c[10001] = &#123;0&#125;; int k = 0; for (int i = 0; a[i] != &#x27;\\0&#x27;; i++) &#123; for (int j = 0; b[j] != &#x27;\\0&#x27;; j++) &#123; if (b[j] == a[i] ) &#123; c[k++] = i; break; &#125; &#125; &#125; for (int i = 0; a[i] != &#x27;\\0&#x27;; i++) &#123; int mask = 1; for (int j = 0; j &lt; k; j++) &#123; if (i == c[j]) &#123; mask = 0; break; &#125; &#125; if (mask == 1) &#123; printf(&quot;%c&quot;, a[i]); &#125; &#125; return 0;&#125; n个数字都不相同的年份123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;stdio.h&gt;void initialize_years(int year, int years[4]) &#123; for (int i = 0; i &lt; 4; i++) &#123; years[i] = 0; &#125; int i = 3; while (year &gt; 0 &amp;&amp; i &gt;= 0) &#123; years[i] = year % 10; year /= 10; i--; &#125;&#125;int main ()&#123; int y; scanf(&quot;%d&quot;, &amp;y); int s[4]; initialize_years(y, s); int n; scanf(&quot;%d&quot;, &amp;n); int cnt = 0; while (1) &#123; int mask = 1; int num[10] = &#123;0&#125;; for (int i = 0; i &lt; 4; i++) &#123; int j = 0; for ( ; j &lt; 10; ) &#123; if (s[i] == j) &#123; num[j]++; break; &#125;else &#123; j++; &#125; &#125; &#125; for (int k = 0; k &lt; 10; k++) &#123; if (n == 4) &#123; if (num[k] != 0 &amp;&amp; num[k] != 1) &#123; mask = 0; break; &#125; &#125;else if (n == 3) &#123; int cnt = 0; for (int l = 0; l &lt; 10; l++) &#123; if (num[l] == 2) &#123; cnt++; &#125; &#125; if (cnt != 1) &#123; mask = 0; break; &#125; &#125;else if (n == 2) &#123; int tag = 0; for (int l = 0; l &lt; 10; l++) if (num[l] == 0) &#123; tag++; &#125; if (tag != 8) &#123; mask = 0; break; &#125; &#125; &#125; if (mask == 0) &#123; y += 1; cnt++; initialize_years(y, s); &#125;else &#123; break; &#125; &#125; printf(&quot;%d &quot;, cnt); for (int i = 0; i &lt; 4; i++) &#123; printf(&quot;%d&quot;, s[i]); &#125; return 0; &#125; 矩阵A乘以B12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;int main() &#123; int Ra, Ca, Rb, Cb; int A[100][100], B[100][100], C[100][100]; scanf(&quot;%d %d&quot;, &amp;Ra, &amp;Ca); for (int i = 0; i &lt; Ra; i++) &#123; for (int j = 0; j &lt; Ca; j++) &#123; scanf(&quot;%d&quot;, &amp;A[i][j]); &#125; &#125; scanf(&quot;%d %d&quot;, &amp;Rb, &amp;Cb); for (int i = 0; i &lt; Rb; i++) &#123; for (int j = 0; j &lt; Cb; j++) &#123; scanf(&quot;%d&quot;, &amp;B[i][j]); &#125; &#125; if (Ca != Rb) &#123; printf(&quot;Error: %d != %d\\n&quot;, Ca, Rb); return 0; &#125; for (int i = 0; i &lt; Ra; i++) &#123; for (int j = 0; j &lt; Cb; j++) &#123; C[i][j] = 0; for (int k = 0; k &lt; Ca; k++) &#123; C[i][j] += A[i][k] * B[k][j]; &#125; &#125; &#125; printf(&quot;%d %d\\n&quot;, Ra, Cb); for (int i = 0; i &lt; Ra; i++) &#123; for (int j = 0; j &lt; Cb; j++) &#123; if (j &gt; 0) printf(&quot; &quot;); printf(&quot;%d&quot;, C[i][j]); &#125; printf(&quot;\\n&quot;); &#125; return 0;&#125; 查验身份证12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;int main ()&#123; int s[17]; int a[17] = &#123;7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2&#125;; int i = 0; int sum = 0; while (i &lt; 17 &amp;&amp; scanf(&quot;%1d&quot;, &amp;s[i]) == 1) &#123; sum += s[i] *a[i]; i++; &#125; char b; scanf(&quot;%c&quot;, &amp;b); sum %= 11; int z[11] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;; char m[11] = &#123;&#x27;1&#x27;, &#x27;0&#x27;, &#x27;X&#x27;, &#x27;9&#x27;, &#x27;8&#x27;, &#x27;7&#x27;, &#x27;6&#x27;, &#x27;5&#x27;, &#x27;4&#x27;, &#x27;3&#x27;, &#x27;2&#x27;&#125;; char mask = &#x27;0&#x27;; for (int i = 0; i &lt; 11; i++) &#123; if (sum == z[i]) &#123; mask = m[i]; &#125; &#125; if (mask == b) &#123; printf(&quot;No problem&quot;); &#125;else &#123; printf(&quot;Incorrect&quot;); &#125; return 0; &#125; 判断题的评判123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;int main ()&#123; int n; scanf(&quot;%d&quot;, &amp;n); int AC[n]; for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;AC[i]); &#125; int WA[n]; int cnt = 0; for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;WA[i]); if (WA[i] == AC[i]) &#123; cnt++; &#125; &#125; double x; x = 1.0 * cnt / n; printf(&quot;%.2f%%&quot;, x * 100); return 0;&#125; 数组元素循环右移问题12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;void reverse(int a[], int l, int r) &#123; while (l &lt; r) &#123; int t = a[l]; a[l] = a[r]; a[r] = t; l++; r--; &#125;&#125;int main () &#123; int n, m; scanf(&quot;%d %d&quot;, &amp;n, &amp;m); m %= n; int s[n]; for (int i = n - 1; i &gt;= 0; i--) &#123; scanf(&quot;%d&quot;, &amp;s[i]); &#125; reverse(s, 0, m - 1); reverse(s, m, n - 1); for (int i = 0; i &lt; n; i++) &#123; printf(&quot;%d &quot;, s[i]); &#125; return 0; &#125; 第七章定义print函数，输出n个*1234567void print(int k)&#123; for (int i = 1; i &lt;= k; i++) printf(&quot;*&quot;); printf(&quot;\\n&quot;);&#125; 定义函数求π的近似值12345678910111213141516171819202122double funpi(double e)&#123; double flag = 1, sum = 0; for (int i = 1;; i++) &#123; double t = flag / (2 * i - 1); if (t &lt; 0) &#123; if (-t &lt; e) break; &#125; else &#123; if (t &lt; e) break; &#125; sum += t; //求和 flag = -flag; //正负反转 &#125; return sum;&#125; 设计函数计算并输出矩形的面积12345void area(int a, int b)&#123; printf(&quot;%d&quot;, a * b);&#125; 定义函数prime，判定正整数n是否素数12345678910#include &lt;math.h&gt;int prime(int n)&#123; for (int i = 2; i &lt;= sqrt(n); i++) if (n % i == 0) return 0; return 1;&#125; 设计函数实现冒泡排序123456789101112131415161718192021222324252627void sort(int a[], int n)&#123; for (int i = 0; i &lt; n - 1; i++) //一趟冒泡排序,把最小的数字放在最末尾 &#123; for (int j = 0; j &lt; n - i - 1; j++) //每经过一趟冒泡排序,需要检索的数字个数-1 &#123; if (a[j] &lt; a[j + 1]) //如果左边的数字小于右边的数字,实现相邻两个数的交换 &#123; int t = a[j]; a[j] = a[j + 1]; a[j + 1] = t; &#125; &#125; &#125;&#125;void print(int a[], int n)&#123; for (int i = 0; i &lt; n; i++) &#123; if (i == 0) printf(&quot;%d&quot;, a[i]); else printf(&quot; %d&quot;, a[i]); &#125; printf(&quot;\\n&quot;);&#125; 设计函数实现矩阵的转置123456789101112131415161718192021void convert(int arr1[][10], int arr2[][10], int x, int y)&#123; for (int i = 0; i &lt; x; i++) for (int j = 0; j &lt; y; j++) arr2[j][i] = arr1[i][j]; // 矩阵行列坐标互换&#125;void print(int arr[][10], int x, int y) //二维数组的行可以不初始化,列一定要初始化&#123; for (int i = 0; i &lt; x; i++) //控制行数 &#123; for (int j = 0; j &lt; y; j++) //控制列数 &#123; if (j == 0) printf(&quot;%d&quot;, arr[i][j]); else printf(&quot; %d&quot;, arr[i][j]); &#125; printf(&quot;\\n&quot;); &#125;&#125; 设计函数实现二分查找1234567891011121314151617int BinSearch(int a[], int n, int x)&#123; int left = 0; //数组最左侧元素下标 int right = n - 1; //数组最右侧元素下标 while (left &lt;= right) &#123; //int mid = (right + left) / 2; int mid = left + (right - left) / 2; //防止数据过大，越界 if (x &lt; a[mid]) left = mid + 1; else if (x &gt; a[mid]) right = mid - 1; else return mid; &#125; return -1;&#125; 定义menu函数，输出菜单选项123456789void Menu()&#123; printf(&quot; Menu\\n&quot;); printf(&quot; (1)--读取数据\\n&quot;); printf(&quot; (2)--数据计算\\n&quot;); printf(&quot; (3)--查找数据\\n&quot;); printf(&quot; (4)--输出数据\\n&quot;); printf(&quot; (0)--退出程序\\n&quot;);&#125; 设计函数计算学生的平均成绩1234567double average(int a[], int n)&#123; double sum = 0; for (int i = 0; i &lt; n; i++) sum = sum += a[i]; return sum / n;&#125; 设计递归函数模拟汉诺塔游戏1234567891011void move(int n, char a, char b, char c)&#123; if (n == 1) printf(&quot;%c--&gt;%c\\n&quot;, a, c); //当只有一个盘子时,直接从起始柱移到目标柱 else &#123; move(n - 1, a, c, b); //第一步:将n-1个盘子由a移动到b,注意此时起始柱是a,中转柱是c,目标柱是b; printf(&quot;%c--&gt;%c\\n&quot;, a, c); //第二步:将第n个盘子从起始柱移到目标柱 move(n - 1, b, a, c); //第三步:将n-1个盘子由b移动到c,注意此时起始柱是b,中转柱是a,目标柱是c; &#125;&#125; 设计递归函数计算Fibonacci数列的第n项1234567int fib(int n)&#123; if (n &lt;= 1) return 1; else return fib(n - 1) + fib(n - 2);&#125; 设计递归函数计算组合1234567int fun(int m, int n)&#123; if (n == 0 || n == m) //c(0,m)和c(m,m)都为1(特判) return 1; else return fun(m - 1, n - 1) + fun(m - 1, n); //组合数公式 c(n,m)=c(n-1,m-1)+c(n-1,m) m&gt;=n&#125; 设计递归函数计算两个整数的最大公约数1234567int gcd(int m, int n) //辗转相除法&#123; if (n == 0) return m; else return gcd(n, m % n);&#125; 设计递归函数计算n！1234567int fac(int n)&#123; if (n &lt;= 1) return 1; else return n * fac(n - 1);&#125; 设计max函数，计算三个整数的最大值123456789int max(int a, int b, int c)&#123; if (a &gt;= b &amp;&amp; a &gt;= c) return a; if (b &gt;= a &amp;&amp; b &gt;= c) return b; if (c &gt;= a &amp;&amp; c &gt;= b) return c;&#125;","categories":[{"name":"答案","slug":"答案","permalink":"https://everlastingblog.top/categories/%E7%AD%94%E6%A1%88/"}],"tags":[{"name":"答案","slug":"答案","permalink":"https://everlastingblog.top/tags/%E7%AD%94%E6%A1%88/"}]},{"title":"C语言作业答案(上)","slug":"C_homework_part1","date":"2026-01-06T16:00:00.000Z","updated":"2026-01-13T11:41:47.412Z","comments":true,"path":"2026/01/07/C_homework_part1/","permalink":"https://everlastingblog.top/2026/01/07/C_homework_part1/","excerpt":"临近期末，打开oj，一笔没动，怎么办！ 不用担心。这里有人经历过。为了不让更多的人经历如此磨难，现有答案供君参考。 若答案顺序与作业顺序不同，可联系笔者！","text":"临近期末，打开oj，一笔没动，怎么办！ 不用担心。这里有人经历过。为了不让更多的人经历如此磨难，现有答案供君参考。 若答案顺序与作业顺序不同，可联系笔者！ 下给出笔者邮箱：2279839810@qq.com 第一章求圆的面积和周长12345678910111213141516171819#include &lt;stdio.h&gt;int main()&#123; double r; double s, c; const double K=3.140000; scanf(&quot;%lf&quot;, &amp;r); s=K*r*r; c=2*K*r; printf(&quot;%lf\\n%lf&quot;, s, c); return 0;&#125; 求2个整数的和1234567891011121314151617#include &lt;stdio.h&gt;int main()&#123; int a, b; scanf(&quot;%d %d&quot;, &amp;a, &amp;b); int c=a+b; printf(&quot;%d&quot;,c); return 0;&#125; 输出2行信息12345678910#include &lt;stdio.h&gt;int main()&#123; printf(&quot;Programing is fun.\\n&quot;); printf(&quot;Programing in language C is even more fun!&quot;);&#125; Hello World!12345678910#include &lt;stdio.h&gt;int main()&#123; printf(&quot;Hello World!&quot;); return 0;&#125; 设计函数求2个整数的最大值12345678int max (int x, int y) &#123; if (x &gt;= y) &#123; return x; &#125; else &#123; return y; &#125;&#125; 求2个整数的最大值1234567891011121314151617#include &lt;stdio.h&gt;int main()&#123; int a, b, max; scanf(&quot;%d %d&quot;, &amp;a, &amp;b); if (a&gt;b) max=a; else max=b; printf(&quot;max=%d&quot;,max); return 0;&#125; This is a C program12345678910#include &lt;stdio.h&gt;int main()&#123; printf(&quot;This is a C program&quot;); return 0;&#125; 第二章猫是液体123456789101112131415#include &lt;stdio.h&gt;int main ()&#123; int a, b, c; scanf(&quot;%d %d %d&quot;, &amp;a, &amp;b, &amp;c); int v = a * b * c; printf(&quot;%d&quot;, v); return 0;&#125; 中英长度单位换算12345678910111213141516171819202122#include &lt;stdio.h&gt;int main()&#123; int cm, foot, inch; scanf(&quot;%d&quot;, &amp;cm); int t=cm/30.48; double n=cm/30.48; foot=t; inch=(n-t)*12; printf(&quot;%d %d&quot;, foot, inch) ; return 0;&#125; 打妖怪12345678910111213141516171819202122#include &lt;stdio.h&gt;int main()&#123; int a, b, c; scanf(&quot;%d %d&quot;, &amp;a, &amp;b); int rem=a%b; int t=a/b; if (rem==0) printf(&quot;%d&quot;, t); else printf(&quot;%d&quot;, t+1); return 0; &#125; 求整数均值123456789101112131415161718#include &lt;stdio.h&gt;int main()&#123; int a, b, c, d; scanf(&quot;%d %d %d %d&quot;, &amp;a, &amp;b, &amp;c, &amp;d); int sum=a+b+c+d; double aver=(a+b+c+d)/4.00; printf(&quot;Sum = %d\\nAverage = %.2f&quot;, sum, aver); return 0;&#125; 整数四则运算1234567891011121314151617#include &lt;stdio.h&gt;int main()&#123; int a, b; scanf(&quot;%d %d&quot;, &amp;a, &amp;b); printf(&quot;%d + %d = %d\\n&quot;, a, b, a+b); printf(&quot;%d - %d = %d\\n&quot;, a, b, a-b); printf(&quot;%d * %d = %d\\n&quot;, a, b, a*b); printf(&quot;%d / %d = %d&quot;, a, b, a/b); return 0; &#125; 分糖果12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;int main ()&#123; int x, y, z; scanf(&quot;%d %d %d&quot;, &amp;x, &amp;y, &amp;z); int a = x / 3; x = a; y += a; z += a; int b = y / 3; x += b; y = b; z += b; int c = z / 3; x += c; y += c; z = c; printf(&quot;%d %d %d&quot;, x, y, z); return 0;&#125; 自由落体12345678910111213141516171819#include &lt;stdio.h&gt;int main ()&#123; int t; scanf(&quot;%d&quot;, &amp;t); int h = 10 * t * t / 2; if (h &gt; 2000) &#123; printf(&quot;2000&quot;); &#125;else &#123; printf(&quot;%d&quot;, h); &#125; return 0;&#125; 计算终止时间1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main () &#123; char str[4]; double num; int a; scanf(&quot;%s %d&quot;, &amp;str, &amp;a); num = atof(str); int NUM = num; int min = NUM % 100; int hour = NUM / 100; int res = a + min; if (res &gt;= 60) &#123; int temp = res / 60; hour += temp; res -= temp * 60; &#125;else if (res &lt; 0) &#123; res = -res; int temp = res / 60; hour -= temp + 1; res -= temp * 60; res = 60 - res; &#125; if (res &gt;= 60) &#123; int temp = res / 60; hour += temp; res -= temp * 60; &#125; printf(&quot;%d%02d&quot;, hour, res); return 0;&#125; 输出四位整数的各位数字12345678910111213141516171819#include &lt;stdio.h&gt;int main()&#123; int num; scanf(&quot;%d&quot;, &amp;num); int a=num/1000, b=num/100-a*10, c=num/10-a*100-b*10, d=num-a*1000-b*100-c*10; printf(&quot;%d=%d+%d*10+%d*100+%d*1000&quot;, num, d, c, b, a); return 0;&#125; 两小时学完C语言12345678910111213141516#include &lt;stdio.h&gt;int main()&#123; int n, k ,m; scanf(&quot;%d %d %d&quot;, &amp;n, &amp;k, &amp;m); int remain=n-k*m; printf(&quot;%d&quot;, remain); return 0;&#125; 计算图形面积12345678910111213141516#include &lt;stdio.h&gt;int main()&#123; int a, b; scanf(&quot;%d %d&quot;, &amp;a, &amp;b); int s=abs(50*a-50*b); printf(&quot;%d&quot;, s); return 0;&#125; 折扣1234567891011121314151617#include &lt;stdio.h&gt;int main()&#123; int ori, dis; scanf(&quot;%d %d&quot;, &amp;ori, &amp;dis); double final=ori*dis/10.00; printf(&quot;%.2f&quot;, final); return 0;&#125; 标准体重和身高的对应关系12345678910111213141516#include &lt;stdio.h&gt;int main()&#123; int h=0; scanf(&quot;%d&quot;, &amp;h); double m=(h-100)*0.9*2; printf(&quot;%.1f&quot;, m); return 0;&#125; 后天123456789101112131415161718#include &lt;stdio.h&gt;int main()&#123; int D=0; scanf(&quot;%d&quot;, &amp;D); D+=2; if(D&gt;7) D-=7; printf(&quot;%d&quot;, D); return 0;&#125; 第三章字母对应的ASCII 码1234567891011121314#include &lt;stdio.h&gt;int main()&#123; char ch; scanf(&quot;%c&quot;, &amp;ch); printf(&quot;%d&quot;, ch); return 0;&#125; 温度转换12345678910111213141516#include &lt;stdio.h&gt;int main()&#123; double f=0; scanf(&quot;%lf&quot;, &amp;f); double c=5.0/9.0*(f-32); printf(&quot;%lf&quot;, c); return 0;&#125; 计算圆的周长1234567891011121314151617#include &lt;stdio.h&gt;int main()&#123; double r; double K=3.14; scanf(&quot;%lf&quot;, &amp;r); double c=2*K*r; printf(&quot;%lf&quot;, c); return 0;&#125; 求三位整数的逆序数12345678910111213141516171819202122#include &lt;stdio.h&gt;int main()&#123; int num = 0; int result = 0; int digital = 0; scanf(&quot;%d&quot;, &amp;num); while (num &gt; 0)&#123; digital = num % 10; result = result * 10 + digital; num /= 10; &#125; printf(&quot;%03d&quot;, result); return 0;&#125; 求三角形面积12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main()&#123; double a, b, c; scanf(&quot;%lf %lf %lf&quot;, &amp;a, &amp;b, &amp;c); double p = (a + b + c) / 2; double s = sqrt(p * (p - a) * (p - b) * (p - c)); printf(&quot;%.2f&quot;, s); return 0;&#125; 计算浮点数相除的余数12345678910111213141516171819202122232425#include &lt;stdio.h&gt;int main()&#123; double a, b; scanf(&quot;%lf %lf&quot;, &amp;a, &amp;b); int k=0; double tag=0.0; double n=0.0; do&#123; n=a-k*b; k++; &#125;while (n&gt;=0); double r=n+b; printf(&quot;%g&quot;, r); return 0;&#125; 年增长率1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main()&#123; int n; scanf(&quot;%d&quot;, &amp;n); double x=pow(2.0, 1.0/n); double res=(x-1.0)*100; printf(&quot;%.2f%%&quot;, res); return 0;&#125; 快速求和123456789101112131415161718192021#include &lt;stdio.h&gt;int main()&#123; int n; scanf(&quot;%d&quot;, &amp;n); int tag; double s=0.0; for (tag=1; tag&lt;=n; tag++)&#123; s+=1.0/(tag*(tag+1.0)); &#125; printf(&quot;%.5f&quot;, s); return 0;&#125; 混合类型数据格式化输入1234567891011121314151617#include &lt;stdio.h&gt;int main()&#123; double a, b; int c; char d; scanf(&quot;%lf %d %c %lf&quot;, &amp;a, &amp;c, &amp;d, &amp;b); printf(&quot;%c %d %.2f %.2f&quot;, d, c, a, b); return 0;&#125; 定期存款123456789101112131415161718#include &lt;stdio.h&gt;int main()&#123; double a, b; scanf(&quot;%lf %lf&quot;, &amp;a, &amp;b); double res1=a*b/100.0; double res2=res1+a; printf(&quot;%11.2f\\n%11.2f\\n%11.2f&quot;, a, res1, res2); return 0;&#125; 日期格式变化1234567891011121314#include &lt;stdio.h&gt;int main()&#123; int m, d, y; scanf(&quot;%d-%d-%d&quot;, &amp;m, &amp;d, &amp;y); printf(&quot;%02d-%02d-%02d&quot;, y, m, d); return 0;&#125; 水果店收款12345678910111213141516#include &lt;stdio.h&gt;int main()&#123; double a, b, c, d; scanf(&quot;%lf %lf %lf %lf,&quot;, &amp;a, &amp;b, &amp;c, &amp;d); double p=2.5*a+1.7*b+2*c+1.2*d; printf(&quot;%.2f&quot;, p); return 0;&#125; 计算房间面积1234567891011121314151617#include &lt;stdio.h&gt;int main()&#123; double a, b; scanf(&quot;%lf\\n%lf&quot;, &amp;a, &amp;b); double c=a*b; printf(&quot;the area of the room:%lf&quot;, c); return 0;&#125; 第四章三天打鱼两天晒网1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;int main()&#123; int n; scanf(&quot;%d&quot;, &amp;n); int tag = n % 5; switch (tag) &#123; case 1: case 2: case 3: printf(&quot;Fishing in day %d&quot;, n); break; default: printf(&quot;Drying in day %d&quot;, n); &#125; return 0; &#125; 闰年123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;int main()&#123; int yr; scanf(&quot;%d&quot;, &amp;yr); int mask1 = yr%400; int lpyr = 0; int mask2 = yr%4; int mask3 = yr%100; if (mask1 == 0) &#123; lpyr = 1; &#125;else &#123; if (mask2 == 0) &#123; if (mask3 != 0 )&#123; lpyr = 1; &#125; &#125; &#125; if (lpyr == 1) &#123; printf(&quot;%d is a leap year!&quot;, yr); &#125;else &#123; printf(&quot;%d isn&#x27;t a leap year!&quot;, yr); &#125; return 0; &#125; 三个整数排序12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;int main()&#123; int a, b, c; scanf(&quot;%d %d %d&quot;, &amp;a, &amp;b, &amp;c); int num1, num2, num3; if (a &gt; b) &#123; if (a &gt; c)&#123; num1 = a; if (b &gt; c)&#123; num2 = b, num3 = c; &#125;else &#123; num2 = c, num3 = b; &#125; &#125;else &#123; num1 = c, num2 = a, num3 = b; &#125; &#125;else&#123; if (b &gt; c)&#123; num1 = b; if (a &gt; c)&#123; num2 = a, num3 = c; &#125;else &#123; num2 = c, num3 = a; &#125; &#125;else&#123; num1 = c, num2 = b, num3 = a; &#125; &#125; printf(&quot;a=%d,b=%d,c=%d&quot;, num3, num2, num1); return 0;&#125; 判断水仙花数1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;stdio.h&gt;int main()&#123; int num; scanf(&quot;%d&quot;, &amp;num); int a, b, c; a = num / 100; b = num / 10 - a * 10; c = num - a * 100 - b * 10; int A = 1; int B = 1; int C = 1; int cnt = 0; do &#123; A *= a; B *= b; C *= c; cnt++; &#125;while (cnt != 3); int res; res = A + B + C; if (res == num) &#123; printf(&quot;YES&quot;); &#125;else &#123; printf(&quot;NO&quot;); &#125; return 0; &#125; 计算奖金123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;int main()&#123; double p; scanf(&quot;%lf&quot;, &amp;p); double bonus; if (p &lt;= 100000) &#123; bonus = p * 0.10; &#125;else if (p &gt; 100000 &amp;&amp; p &lt;= 200000) &#123; bonus = 10000 + (p - 100000) * 0.075; &#125;else if (p &gt; 200000 &amp;&amp; p &lt;= 400000) &#123; bonus = 17500 + (p - 200000) * 0.05; &#125;else if (p &gt; 400000 &amp;&amp; p &lt;= 600000) &#123; bonus = 27500 + (p - 400000) * 0.03; &#125;else if (p &gt; 600000 &amp;&amp; p &lt;= 1000000) &#123; bonus = 33500 + (p - 600000) * 0.015; &#125;else if (p &gt; 1000000) &#123; bonus = 39500 + (p - 1000000) * 0.01; &#125;//恶心 printf(&quot;%.2f&quot;, bonus); return 0;&#125; 按公式计算y和z的值123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main()&#123; double x = 0.0; scanf (&quot;%lf&quot;, &amp;x); double y, z; if (x &gt;= 1 &amp;&amp; x &lt; 2) &#123; y = x * x + 1.0; z = 3.0 * x + 5.0; &#125;else if (x &gt;= 2 &amp;&amp; x &lt;= 2.5) &#123; y = x * x + 1.0; z = 2.0 * sin(x) - 1.0; &#125;else if (x &gt; 2.5 &amp;&amp; x &lt; 3) &#123; y = x * x - 1.0; z = 2.0 * sin (x) - 1.0; &#125;else if (x &gt;= 3 &amp;&amp; x &lt; 5) &#123; y = x * x - 1.0; z = sqrt (1.0 + x * x); &#125;else if (x &gt;= 5 &amp;&amp; x &lt; 8) &#123; y = x * x - 1.0; z = x * x - 2 * x + 5; &#125; printf(&quot;%lf\\n%lf&quot;, y, z); return 0;&#125; 24小时时间记法转12小时时间记法123456789101112131415161718#include &lt;stdio.h&gt;int main()&#123; int hor, min, sec; scanf(&quot;%d %d %d&quot;, &amp;hor, &amp;min, &amp;sec); if (hor &gt;= 12) &#123; printf(&quot;%d %d %d PM&quot;, hor-12, min, sec); &#125;else &#123; printf(&quot;%d %d %d AM&quot;, hor, min, sec); &#125; return 0; &#125; 能否构成三角形123456789101112131415161718#include &lt;stdio.h&gt;int main()&#123; int a, b, c; scanf(&quot;%d %d %d&quot;, &amp;a, &amp;b, &amp;c); if (a+b &gt; c &amp;&amp; a+c &gt; b &amp;&amp; b+c &gt; a) &#123; printf(&quot;YES&quot;); &#125;else &#123; printf(&quot;NO&quot;); &#125; return 0;&#125; 找出3个整数居中的整数123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;int main()&#123; int a, b, c; scanf(&quot;%d %d %d&quot;, &amp;a, &amp;b, &amp;c); int res; if (a &gt; b) &#123; if (b &gt; c) &#123; res = b; &#125;else if (a &gt; c) &#123; res = c; &#125;else &#123; res = a; &#125; &#125;else if (a &gt; c) &#123; res = a; &#125;else if (b &gt; c) &#123; res = c; &#125;else &#123; res = b; &#125; printf(&quot;%d&quot;, res); return 0;&#125; 学生成绩评定1234567891011121314151617181920#include &lt;stdio.h&gt;int main()&#123; int scr; scanf(&quot;%d&quot;, &amp;scr); if (scr &gt; 85) &#123; printf(&quot;very good&quot;); &#125;else if (scr &lt;= 85 &amp;&amp; scr &gt;= 60) &#123; printf(&quot;good&quot;); &#125;else &#123; printf(&quot;no good&quot;); &#125; return 0; &#125; 求月份对应的英文名称及天数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;stdio.h&gt;int main()&#123; int mth; scanf(&quot;%d&quot;, &amp;mth); switch ( mth ) &#123; case 1: printf(&quot;January,31&quot;); break; case 2: printf(&quot;February,28/29&quot;); break; case 3: printf(&quot;March,31&quot;); break; case 4: printf(&quot;April,30&quot;); break; case 5: printf(&quot;May,31&quot;); break; case 6: printf(&quot;June,30&quot;); break; case 7: printf(&quot;July,31&quot;); break; case 8: printf(&quot;August,31&quot;); break; case 9: printf(&quot;September,30&quot;); break; case 10: printf(&quot;October,31&quot;); break; case 11: printf(&quot;November,30&quot;); break; case 12: printf(&quot;December,31&quot;); break; &#125; return 0; &#125; 百分制分数转换为等级12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;int main()&#123; int scr; scanf(&quot;%d&quot;, &amp;scr); int tag = scr; scr /= 10; switch ( scr ) &#123; case 10: case 9: printf(&quot;score=%d,grade:A&quot;, tag); break; case 8: printf(&quot;score=%d,grade:B&quot;, tag); break; case 7: printf(&quot;score=%d,grade:C&quot;, tag); break; case 6: printf(&quot;score=%d,grade:D&quot;, tag); break; default: printf(&quot;score=%d,grade:E&quot;, tag); break; &#125; return 0;&#125; 第五章1求若干整数的最大值1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;int main()&#123; int n; scanf(&quot;%d&quot;, &amp;n); int max = 0; int cnt = 1; int num = 0; scanf(&quot;%d&quot;, &amp;max); for (cnt = 1; cnt &lt; n; cnt++) &#123; scanf(&quot;%d&quot;, &amp;num); if (num &gt; max) &#123; max = num; &#125; &#125; printf(&quot;%d&quot;, max); return 0;&#125; n！12345678910111213141516171819202122#include &lt;stdio.h&gt;int main()&#123; int num = 0; int res = 1; int fac = 1; scanf(&quot;%d&quot;, &amp;num); while (fac &lt;= num)&#123; res *= fac; fac++; &#125; printf (&quot;%d!=%d&quot;, num, res); return 0;&#125; 最大公约数12345678910111213141516171819202122#include &lt;stdio.h&gt;int main()&#123; int num1, num2; scanf(&quot;%d %d&quot;, &amp;num1, &amp;num2); int mask = 0; while (num2 != 0) &#123; mask = num1 % num2; num1 = num2; num2 = mask; &#125; printf(&quot;%d&quot;, num1); return 0;&#125;//解决了1 2的公约数是1的问题 最小值和最大值1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;int main ()&#123; int n = 0; scanf(&quot;%d&quot;, &amp;n); int first = 0; scanf(&quot;%d&quot;, &amp;first); int max = first; int min = first; int num = 0; int cntmax = 1; int cntmin = 1; for (int cnt = 1; cnt &lt; n; cnt++) &#123; scanf(&quot;%d&quot;, &amp;num); if (num &gt; max) &#123; max = num; cntmax = 1; &#125;else if (num == max) &#123; cntmax++; &#125; if (num &lt; min) &#123; min = num; cntmin = 1; &#125;else if (num == min) &#123; cntmin++; &#125; &#125; printf(&quot;%d %d\\n%d %d&quot;, min, cntmin, max, cntmax); return 0;&#125; 连续因子1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;int main() &#123; long long n; scanf(&quot;%lld&quot;, &amp;n); long long len = 0; long long ans = 0; for (long long i = 2; i * i &lt;= n; i++) &#123; long long temp = 1; long long k = i; while (temp * k &lt;= n) &#123; temp *= k; if (n % temp == 0 &amp;&amp; k - i + 1 &gt; len) &#123; len = k - i + 1; ans = i; &#125; k++; &#125; &#125; if (len == 0) &#123; printf(&quot;1\\n%lld\\n&quot;, n); &#125; else &#123; printf(&quot;%lld\\n&quot;, len); for (int i = 0; i &lt; len; i++) &#123; if (i &gt; 0) printf(&quot;*&quot;); printf(&quot;%lld&quot;, ans + i); &#125; printf(&quot;\\n&quot;); &#125; return 0;&#125; 打印沙漏12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;stdio.h&gt;int main ()&#123; int n; scanf(&quot;%d&quot;, &amp;n); int sum = -1; int i = 2; while (n - sum - i &gt;= 0) &#123; sum += i; i += 4; &#125; int k = i; int j = 1; int u = 1; while (k &gt; 2) &#123; int t = k / 2; int j = u; while (t &gt; 2) &#123; if (t == 3) &#123; printf(&quot;*\\n&quot;); &#125;else &#123; printf(&quot;*&quot;); &#125; t--; &#125; while (j &gt; 0 &amp;&amp; k &gt; 6) &#123; printf(&quot; &quot;); j--; &#125; k -= 4; u += 1; &#125; k = i; u -= 3; int p = 3; int m = 3; while (u &gt;= 0) &#123; j = u; p = m; while (j &gt; 0) &#123; printf(&quot; &quot;); j--; &#125; while (p &gt; 0) &#123; if (p == 1) &#123; printf(&quot;*\\n&quot;); &#125;else &#123; printf(&quot;*&quot;); &#125; p--; &#125; m += 2; u -= 1; &#125; int difference = n - sum; printf(&quot;%d&quot;, difference); return 0;&#125; 念数字123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;stdio.h&gt;int main()&#123; int x; scanf(&quot;%d&quot;, &amp;x); int mask = 1; int t = x; if (x &lt; 0) &#123; printf(&quot;fu &quot;); x = - x; t = - t; &#125; while (t &gt; 9) &#123; t /= 10; mask *= 10; &#125; do &#123; int d = x / mask; switch (d) &#123; case 0: printf(&quot;ling&quot;); break; case 1: printf(&quot;yi&quot;); break; case 2: printf(&quot;er&quot;); break; case 3: printf(&quot;san&quot;); break; case 4: printf(&quot;si&quot;); break; case 5: printf(&quot;wu&quot;); break; case 6: printf(&quot;liu&quot;); break; case 7: printf(&quot;qi&quot;); break; case 8: printf(&quot;ba&quot;); break; case 9: printf(&quot;jiu&quot;); break; &#125; x %= mask; mask /= 10; if (mask &gt; 0) &#123; printf(&quot; &quot;); &#125; &#125;while (mask &gt; 0); return 0; &#125; N个有理数求和1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ll long longll abss(ll x) &#123; return x &lt; 0 ? -x : x; &#125;ll gcd(ll a, ll b) &#123; if (a &lt; 0) a = -a; if (b &lt; 0) b = -b; while (b != 0) &#123; ll t = a % b; a = b; b = t; &#125; return a;&#125;int main() &#123; int n; if (scanf(&quot;%d&quot;, &amp;n) != 1) return 0; ll num = 0; ll den = 1; for (int i = 0; i &lt; n; ++i) &#123; ll a, b; scanf(&quot;%lld/%lld&quot;, &amp;a, &amp;b); ll g = gcd(den, b); ll den1 = den / g; ll b1 = b / g; ll new_num = num * b1 + a * den1; ll new_den = den * b1; ll g2 = gcd(abss(new_num), new_den); new_num /= g2; new_den /= g2; if (new_den &lt; 0) &#123; new_den = -new_den; new_num = -new_num; &#125; num = new_num; den = new_den; &#125; ll integer = num / den; ll remainder = num % den; if (remainder == 0) &#123; printf(&quot;%lld&quot;, integer); putchar(&#x27;\\n&#x27;); &#125; else &#123; if (integer != 0) &#123; printf(&quot;%lld&quot;, integer); putchar(&#x27; &#x27;); printf(&quot;%lld&quot;, remainder); putchar(&#x27;/&#x27;); printf(&quot;%lld&quot;, den); putchar(&#x27;\\n&#x27;); &#125; else &#123; printf(&quot;%lld&quot;, remainder); putchar(&#x27;/&#x27;); printf(&quot;%lld&quot;, den); putchar(&#x27;\\n&#x27;); &#125; &#125; return 0;&#125; 画方块1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main()&#123; double n; char c; scanf(&quot;%lf %c&quot;, &amp;n, &amp;c); int cnt = 0; double mask = 0.0; int tag = round (n / 2); while (cnt &lt;= n) &#123; cnt++; printf(&quot;%c&quot;, c); if (cnt == n) &#123; printf(&quot;\\n&quot;); cnt = 0; mask ++; if (mask == tag) &#123; break; &#125; &#125; &#125; return 0;&#125; 守形数12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;int main()&#123; int min, max; scanf(&quot;%d %d&quot;, &amp;min, &amp;max); int tag = min; int mask = 10; int test = 0; int isfirst = 1; for (tag = min; tag &lt;= max; tag++) &#123; int t = tag * tag; int p = tag; mask = 1; while (p &gt; 0) &#123; p /= 10; mask *= 10; &#125; int cur = t % mask; if (cur == tag) &#123; if (isfirst == 1) &#123; printf(&quot;%d&quot;, tag); test = 1; isfirst = 0; &#125;else&#123; printf(&quot; %d&quot;, tag); &#125; &#125; &#125; if (test == 0) &#123; printf(&quot;No exist&quot;); &#125; return 0;&#125; 含数字5且是3的倍数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;int main ()&#123; int m, n; scanf(&quot;%d %d&quot;, &amp;m, &amp;n); int i = m; int tag = 1; while (i &lt;= n) &#123; int j = 1; int k = i; int mask = 0; while (k &gt; 0) &#123; int num = k % 10; if (num == 5) &#123; mask = 1; break; &#125;else &#123; k /= 10; &#125; &#125; if (i % 3 == 0 &amp;&amp; mask == 1) &#123; if (tag == 1) &#123; printf(&quot;%d&quot;, i); tag = 0; &#125;else &#123; printf(&quot; %d&quot;, i); &#125; &#125; i++; &#125; if (tag == 1) &#123; printf(&quot;No exist&quot;); &#125; return 0; &#125; 小球自由落体123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;int main()&#123; int n; scanf(&quot;%d&quot;, &amp;n); int cnt = 0; double res = 0.0; double h = 100.0; int tag = 1; for (cnt = 0; cnt&lt; n; cnt++) &#123; if (tag == 1) &#123; res += 100; tag = 0; &#125;else &#123; h /= 2; res += h*2; &#125; &#125; printf(&quot;%lf %lf&quot;, res, h/2); return 0;&#125; 鸡兔同笼1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;int main()&#123; int h, f; scanf(&quot;%d %d&quot;, &amp;h, &amp;f); int c = 0; int r = 0; int res = 0; for (r = 0; r&lt;= h; r++) &#123; c = h - r; if (4*r + 2* c == f) &#123; res = 1; break; &#125; &#125; if (res == 1) &#123; printf (&quot;%d %d&quot;, c, r); &#125;else &#123; printf(&quot;Error&quot;); &#125; return 0; &#125; 计算π的近似值123456789101112131415161718192021222324#include &lt;stdio.h&gt;int main()&#123; int n; scanf(&quot;%d&quot;, &amp;n); int cnt = 0; double res = 0.0; int i = 1; int sign = 1; for (cnt = 0; cnt &lt; 2*n; cnt++) &#123; res += sign * 1.0 / i; i += 2; sign = -sign; &#125; printf(&quot;%lf&quot;, res*4.0); return 0;&#125; “韩信点兵”数1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;int main()&#123; int min, max; scanf(&quot;%d %d&quot;, &amp;min, &amp;max); int res = 0; int cnt = 0; int tag = 1; for (res = min; res &lt;= max ; res++) &#123; if (res % 3 == 2 &amp;&amp; res % 5 == 3 &amp;&amp; res % 7 == 4) &#123; if ( tag == 1) &#123; printf(&quot;%d&quot;, res); tag = 0; cnt++; &#125;else &#123; cnt++; printf(&quot; %d&quot;, res); &#125; &#125; &#125; if (cnt == 0) &#123; printf(&quot;total=0&quot;); &#125;else &#123; printf(&quot;\\ntotal=%d&quot;, cnt); &#125; return 0;&#125; 祖孙年龄123456789101112131415161718#include &lt;stdio.h&gt;int main()&#123; int x, y1, y2, y3; scanf(&quot;%d %d %d %d&quot;, &amp;x, &amp;y1, &amp;y2, &amp;y3); int res = x - y1 - y2 - y3; if (res % 2 == 0) &#123; printf(&quot;%d&quot;, res / 2 ); &#125;else &#123; printf(&quot;%d&quot;, (res + 1) / 2 ); &#125; return 0;&#125; 输出Fibonacci数列的前n项123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;int main()&#123; int n; scanf(&quot;%d&quot;, &amp;n); int i = 1; int j = 0; int k; int cnt; int p = 1; for (cnt = 0; cnt &lt; n; cnt++) &#123; printf(&quot;%10d&quot;, i); if (p % 5 == 0 &amp;&amp; p!= 0) &#123; printf(&quot;\\n&quot;); &#125; k = i; i = j + i; j = k; p++; &#125; return 0;&#125; 菱形图案1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;stdio.h&gt;int main ()&#123; int n; scanf(&quot;%d&quot;, &amp;n); n += 1; int cnt = 1; int CNT = 1; for (int s = n - 1; s &gt; 0; s--) &#123; for (int cnt_s = s; cnt_s &gt; 1; cnt_s--) &#123; printf(&quot; &quot;); &#125; int cnt_q = 1; for ( ; cnt_q &lt;= cnt; cnt_q++) &#123; if (cnt_q == cnt) &#123; printf(&quot;*\\n&quot;); &#125;else &#123; printf(&quot;*&quot;); &#125; &#125; cnt += 2; &#125; int CNT_S = 1; int mask = 0; int tag = 1; for (int S = n - 2; S &gt; 0; S--) &#123; int cnt_S = 1; for (int cnt_S = 1 ; cnt_S &lt;= CNT_S; cnt_S++) &#123; mask++; if (cnt_S == 1 &amp;&amp; tag == 0) &#123; printf(&quot;\\n &quot;); &#125;else &#123; printf(&quot; &quot;); &#125; &#125; int cnt_Q = 2 * (n - 1) - 3; for ( ; cnt_Q &gt; 0; cnt_Q--) &#123; if (cnt_Q == 1) &#123; printf(&quot;*&quot;); &#125;else &#123; printf(&quot;*&quot;); &#125; &#125; CNT += 1; n--; CNT_S++; tag = 0; &#125; return 0;&#125; 计算某分数序列的前n项之和12345678910111213141516171819202122232425#include &lt;stdio.h&gt;int main()&#123; int n; scanf(&quot;%d&quot;, &amp;n); double sum = 0.0; int cnt = 0; double i = 2.0; double j = 1.0; double k = 2.0; for (cnt = 0; cnt &lt; n; cnt++) &#123; sum += i / j; k = i; i += j; j = k; &#125; printf(&quot;%lf&quot;, sum); return 0;&#125; 素数12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;int main()&#123; int num; int i; int isprime = 1; scanf(&quot;%d&quot;, &amp;num); if (num == 1) &#123; printf(&quot;NO&quot;); goto final; &#125;else &#123; for (i = 2; i &lt; num; i++)&#123; if (num % i == 0)&#123; isprime = 0; break; &#125; &#125; if (isprime == 1) &#123; printf(&quot;YES&quot;); &#125;else &#123; printf(&quot;NO&quot;); &#125;&#125;final: return 0;&#125; 第五章2寻找25012345678910111213141516171819202122#include &lt;stdio.h&gt;int main ()&#123; int result = 1; int cnt = 0; do &#123; int num = 0; result = scanf(&quot;%d&quot;, &amp;num); cnt++; if (num == 250) &#123; break; &#125; &#125;while (result == 1); printf(&quot;%d&quot;, cnt); return 0; &#125; 计算阶乘和123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;int main ()&#123; int n; scanf(&quot;%d&quot;, &amp;n); int cnt = 1; int s = 0; do &#123; int count = 1; int cur = 1; while (count &lt;= cnt) &#123; cur = count * cur; count++; &#125; s += cur; cnt++; &#125; while (cnt &lt;= n); printf(&quot;%d&quot;, s); return 0;&#125; 整除光棍12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;int main()&#123; int x; scanf(&quot;%d&quot;, &amp;x); int count = 1; int a = 1; while (a &lt; x) &#123; a = a * 10 + 1; count++; &#125; printf(&quot;%d&quot;, a / x); int t = a % x; while (t != 0) &#123; //利用循环将商从高到低位依次输出，直到余数为0。 t = t * 10 + 1; printf(&quot;%d&quot;, t / x); count++; t %= x; &#125; printf(&quot; %d&quot;, count); return 0;&#125; 求幂级数展开的部分和123456789101112131415161718192021222324#include &lt;stdio.h&gt;int main ()&#123; double x; scanf(&quot;%lf&quot;, &amp;x); double res = 1; int t = x; double temp = 1; int cnt = 1; while (temp &gt;= 0.000001) &#123; temp = temp * x / cnt; res += temp; cnt++; &#125; printf(&quot;%.5f&quot;, res); return 0;&#125; 求奇数和123456789101112131415161718192021222324#include &lt;stdio.h&gt;int main ()&#123; int num = 1; int temp = 0; int res = 0; while (num &gt; 0) &#123; scanf(&quot;%d&quot;, &amp;num); if (num &gt; 0) &#123; temp = num % 2; if (temp != 0) &#123; res += num; &#125; &#125; &#125; printf(&quot;%d&quot;, res); return 0;&#125; 猴子吃桃问题12345678910111213141516171819#include &lt;stdio.h&gt;int main ()&#123; int n; scanf(&quot;%d&quot;, &amp;n); int res = 1; for (int cnt = 1; cnt &lt; n; cnt++) &#123; res = (res + 1) * 2; &#125; printf(&quot;%d&quot;, res); return 0;&#125; 水仙花数123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt;int main ()&#123; int n; scanf(&quot;%d&quot;, &amp;n); int first = 1; int i = 1; while (i &lt; n) &#123; first *= 10; i++; &#125; i = first; while (i &lt; first * 10) &#123; int t = i; int sum = 0; do &#123; int d = t % 10; t /= 10; int p = d; int j = 1; while (j &lt; n) &#123; p *= d; j++; &#125; sum += p; &#125; while (t &gt; 0); if (sum == i) &#123; printf(&quot;%d\\n&quot;, i); &#125; i++; &#125; return 0;&#125; 兔子繁衍问题1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;int main() &#123; int N; scanf(&quot;%d&quot;, &amp;N); if (N &lt;= 1) &#123; printf(&quot;1\\n&quot;); return 0; &#125; int a = 1; int b = 1; int month = 2; while (b &lt; N) &#123; int c = a + b; a = b; b = c; month++; &#125; printf(&quot;%d\\n&quot;, month); return 0;&#125; 黑洞数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;stdio.h&gt;int main ()&#123; int num = 0; scanf(&quot;%d&quot;, &amp;num); int x = num; int temp = 0; int X = 0; int cnt = 1; do &#123; int c = 0; int b = 0; int a = 0; c = x / 100; b = x / 10 - c * 10; a = x - c * 100 - b * 10; if (a &gt; b) &#123; if (b &gt; c) &#123; temp = a * 100 + b * 10 + c; x = c * 100 + b * 10 + a; &#125;else if (a &gt; c) &#123; temp = a * 100 + c * 10 + b; x = b * 100 + c * 10 + a; &#125;else &#123; temp = c * 100 + a * 10 + b; x = b * 100 + a * 10 + c; &#125; &#125;else if (a &gt; c) &#123; temp = b * 100 + a * 10 + c; x = c * 100 + a * 10 + b; &#125;else if (b &gt; c) &#123; temp = b * 100 + c * 10 + a; x = a * 100 + c * 10 + b; &#125;else &#123; temp = c * 100 + b * 10 + a; x = a * 100 + b * 10 + c; &#125; int mask = temp - x; if (mask == 495) &#123; printf(&quot;%d: %d - %d = %d&quot;, cnt, temp, x, mask); &#125;else &#123; printf(&quot;%d: %d - %d = %d\\n&quot;, cnt, temp, x, mask); &#125; X = x; x = mask; cnt++; &#125;while (temp - X != 495); return 0;&#125; 输出三角形字符阵列12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;int main ()&#123; int n; scanf(&quot;%d&quot;, &amp;n); char chr = &#x27;A&#x27;; int cnt = 0; int N = n; int mask = 1; while (cnt &lt;= n) &#123; if (N == 1 &amp;&amp; mask == 1) &#123; printf(&quot;%c\\n&quot;, chr); &#125;else if (N &gt; 1 &amp;&amp; mask == 1) &#123; printf(&quot;%c &quot;, chr); &#125;else if (N == 1 &amp;&amp; mask == 0) &#123; printf(&quot;%c&quot;, chr); &#125; chr++; N--; if (N == 0) &#123; n -= 1; N = n; cnt = 0; &#125; if (N == 1 &amp;&amp; n == 1) &#123; mask = 0; &#125; cnt++; &#125; return 0; &#125; 求整数的位数及各位数字之和123456789101112131415161718192021#include &lt;stdio.h&gt;int main() &#123; long long N; scanf(&quot;%lld&quot;, &amp;N); int digits = 0; int sum = 0; long long temp = N; while (temp &gt; 0) &#123; sum += temp % 10; temp /= 10; digits++; &#125; printf(&quot;%d %d\\n&quot;, digits, sum); return 0;&#125; 特殊a串数列求和123456789101112131415161718192021#include &lt;stdio.h&gt;int main ()&#123; int a, n; scanf(&quot;%d %d&quot;, &amp;a, &amp;n); int temp = a; int res = a; for (int cnt = 0; cnt &lt; n - 1; cnt++) &#123; temp = temp * 10 + a; res += temp; &#125; printf(&quot;%d&quot;, res); return 0;&#125; 验证“哥德巴赫猜想”1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdio.h&gt;int main ()&#123; long int n; scanf(&quot;%ld&quot;, &amp;n); long int b = 0; long int num1 = 0; long int num2 = 0; for (long int t = 2; t &lt;= n; t++) &#123; int isPrime = 1; for (long int i = 2; i * i &lt; t; i++) &#123; if (t % i == 0 &amp;&amp; t != 2) &#123; isPrime = 0; break; &#125; &#125; if (isPrime == 1) &#123; num1 = t; b = n - t; &#125; int isprime = 1; for (long int j = 2; j * j &lt; b; j++) &#123; if (b % j == 0 &amp;&amp; b != 2) &#123; isprime = 0; break; &#125; &#125; if (isprime == 1) &#123; num2 = b; break; &#125; &#125; printf(&quot;%ld = %ld + %ld&quot;, n, num1, num2); return 0; &#125; 换硬币1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;int main ()&#123; int x; scanf(&quot;%d&quot;, &amp;x); int one; int two; int five; int mask = 0; for (five = x / 5; five != 0; five--) &#123; for (two = x / 2; two != 0; two--) &#123; for (one = x - 1; one != 0; one--) &#123; if (one + two * 2 + five * 5 == x) &#123; int cnt = one + two + five; printf(&quot;fen5:%d, fen2:%d, fen1:%d, total:%d\\n&quot;, five, two, one, cnt); mask++; &#125; &#125; &#125; &#125; printf(&quot;count = %d&quot;, mask); return 0;&#125; 统计素数并求和12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;int main () &#123; int m, n; scanf(&quot;%d %d&quot;, &amp;m, &amp;n); int cnt = 0; int res = 0; if (m &lt; 2) &#123; m = 2; &#125; for (int t = m; t &lt;= n; t++) &#123; int isPrime = 1; for (int x = 2; x &lt; t; x++) &#123; int rem = t % x; if (rem == 0) &#123; isPrime = 0; break; &#125; &#125; if (isPrime == 1) &#123; res += t; cnt++; &#125; &#125; printf(&quot;%d %d&quot;, cnt, res); return 0;&#125; 求e的近似值1234567891011121314151617181920212223#include &lt;stdio.h&gt;int main ()&#123; int n; scanf(&quot;%d&quot;, &amp;n); double e = 1; double res = 1; for (int num = 1; num &lt;= n; num++) &#123; res = 1; for (int t = 1; t &lt;= num; t++) &#123; res *= t; &#125; e += 1.0 / res; &#125; printf(&quot;%.8f&quot;, e); return 0;&#125; 求平方与倒数序列的部分和123456789101112131415161718#include &lt;stdio.h&gt;int main ()&#123; double m, n; scanf(&quot;%lf %lf&quot;, &amp;m, &amp;n); double s = 0; for ( ; m &lt;= n; m++) &#123; s += m * m + 1.0 / m; &#125; printf(&quot;%.6f&quot;, s); return 0;&#125; 求组合数1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;int main()&#123; int n, m; scanf(&quot;%d %d&quot;, &amp;n, &amp;m); double N = 1; for (int numN = 1; numN &lt;= n; numN++) &#123; N *= numN; &#125; double M = 1; for (int numM = 1; numM &lt;= m; numM++) &#123; M *= numM; &#125; double C = 1; for (int numC = 1; numC &lt;= m - n; numC++) &#123; C *= numC; &#125; double res = M / N / C; printf(&quot;%.0f&quot;, res); return 0;&#125; 求简单交错序列前N项和12345678910111213141516171819202122#include &lt;stdio.h&gt;int main ()&#123; int n; scanf(&quot;%d&quot;, &amp;n); int den = 1; double s = 0; int sign = 1; for (int cnt = 0; cnt &lt; n; cnt++) &#123; s += sign * 1.0 / den; den += 3; sign = -sign; &#125; printf(&quot;%.4f&quot;, s); return 0;&#125; 最佳情侣身高差123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;int main ()&#123; int n; scanf(&quot;%d&quot;, &amp;n); char x; double h; int cnt = 0; do &#123; scanf(&quot; %c&quot;, &amp;x); scanf(&quot;%lf&quot;, &amp;h); if (x == &#x27;M&#x27;) &#123; h /= 1.09; &#125;else &#123; h *= 1.09; &#125; printf(&quot;%.2f\\n&quot;, h); cnt++; &#125; while (cnt &lt; n); return 0;&#125;","categories":[{"name":"答案","slug":"答案","permalink":"https://everlastingblog.top/categories/%E7%AD%94%E6%A1%88/"}],"tags":[{"name":"答案","slug":"答案","permalink":"https://everlastingblog.top/tags/%E7%AD%94%E6%A1%88/"}]},{"title":"2025武汉新生赛部分题解及游记","slug":"2025-Wuhan-Freshman-League","date":"2025-12-21T16:00:00.000Z","updated":"2026-01-13T11:41:42.455Z","comments":true,"path":"2025/12/22/2025-Wuhan-Freshman-League/","permalink":"https://everlastingblog.top/2025/12/22/2025-Wuhan-Freshman-League/","excerpt":"游记2025 年已经见底，今年最后一场参加的线下赛也告一段落。不知不觉已经过了快半年的时间，在这里先感谢这半年来帮助过我的学长，同学们，感谢他们作为我的领路人，帮助我应对大学里的事物，带我入门算法，学习计算机相关的知识。希望未来的自己能够争气点。","text":"游记2025 年已经见底，今年最后一场参加的线下赛也告一段落。不知不觉已经过了快半年的时间，在这里先感谢这半年来帮助过我的学长，同学们，感谢他们作为我的领路人，帮助我应对大学里的事物，带我入门算法，学习计算机相关的知识。希望未来的自己能够争气点。 本次比赛仍需要反思的，首先是保持冷静。A 题样例都没看就开始搓，最后发现时几乎是全部重写，浪费了大量时间。另外对于一些细节方面仍需注意。例如算式中存在的计算符的优先性。最后对于拿不太准的代码，应当多造样例多测，这样能避免很多不应该出现的罚时。 这次是第二次去华农参加的比赛。相对于第一次，这次抽到了怎么按也按不动的键盘，刚交完 Wrong Answer 后就蓝屏的电脑，运气还是差了点 TAT。但这次发的面包好吃(虽然不咋饿)。这次仍然很幸运的拿到了签到题的一血，让我也不至于空手而归。另外，华农不愧是华“农”，比赛完在华农乱逛，田，一望无际的田~~ 经历了这次比赛，意识到了自己与强者之间的差距真的很大。。。在算法这条路上仍是任重道远。希望自己以后加油吧！ 部分题解L - 那我问你题意：输入三个整数 a，b，c，输出“The paper you submitted have a Pros and b Cons, so I have c Questions for you.”。 代码：123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;using ld = long double;using pi = pair&lt;ll, ll&gt;;#define fi first#define se secondconst int MAXN = 6e7;const double eps = 1e-5;const ll mod = 1e9 + 7;void solve ()&#123; ll a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; cout &lt;&lt; &quot;The paper you submitted have &quot; &lt;&lt; a &lt;&lt; &quot; Pros and &quot; &lt;&lt; b &lt;&lt; &quot; Cons, so I have &quot; &lt;&lt; c &lt;&lt; &quot; Questions for you.&quot;;&#125;int main ()&#123; ios::sync_with_stdio(0); cin.tie(0); int _ = 1; // cin &gt;&gt; _; while (_--) &#123; solve(); &#125; return 0;&#125; A - 昨日重现题意：给定一个长度不超过 100 的字符串，在五所大学(HUST, WHU, WHUT, HZAU, CCNU)的缩写中，找出在字符串中作为子序列出现次数最多且字典序最小的一个，输出大学的缩写及最大次数。 思路：这里就不深究此题了，for 循环足以解决。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;using ld = long double;using pi = pair&lt;ll, ll&gt;;#define fi first#define se secondconst int MAXN = 6e7;const double eps = 1e-5;const ll mod = 1e9 + 7;void solve ()&#123; string s; cin &gt;&gt; s; vector &lt;ll&gt; cnt(5, 0); ll n = s.size(); for (ll i = 0; i &lt; n; i++) &#123; if (s[i] == &#x27;C&#x27;) &#123; for (ll j = i + 1; j &lt; n; j++) &#123; if (s[j] == &#x27;C&#x27;) &#123; for (ll k = j + 1; k &lt; n; k++) &#123; if (s[k] == &#x27;N&#x27;) &#123; for (ll l = k + 1; l &lt; n; l++) &#123; if (s[l] == &#x27;U&#x27;) cnt[0]++; &#125; &#125; &#125; &#125; &#125; &#125; &#125; for (ll i = 0; i &lt; n; i++) &#123; if (s[i] == &#x27;H&#x27;) &#123; for (ll j = i + 1; j &lt; n; j++) &#123; if (s[j] == &#x27;U&#x27;) &#123; for (ll k = j + 1; k &lt; n; k++) &#123; if (s[k] == &#x27;S&#x27;) &#123; for (ll l = k + 1; l &lt; n; l++) &#123; if (s[l] == &#x27;T&#x27;) cnt[1]++; &#125; &#125; &#125; &#125; &#125; &#125; &#125; for (ll i = 0; i &lt; n; i++) &#123; if (s[i] == &#x27;H&#x27;) &#123; for (ll j = i + 1; j &lt; n; j++) &#123; if (s[j] == &#x27;Z&#x27;) &#123; for (ll k = j + 1; k &lt; n; k++) &#123; if (s[k] == &#x27;A&#x27;) &#123; for (ll l = k + 1; l &lt; n; l++) &#123; if (s[l] == &#x27;U&#x27;) cnt[2]++; &#125; &#125; &#125; &#125; &#125; &#125; &#125; for (ll i = 0; i &lt; n; i++) &#123; if (s[i] == &#x27;W&#x27;) &#123; for (ll j = i + 1; j &lt; n; j++) &#123; if (s[j] == &#x27;H&#x27;) &#123; for (ll k = j + 1; k &lt; n; k++) &#123; if (s[k] == &#x27;U&#x27;) &#123; for (ll l = k + 1; l &lt; n; l++) &#123; if (s[l] == &#x27;T&#x27;) cnt[4]++; &#125; &#125; &#125; &#125; &#125; &#125; &#125; for (ll i = 0; i &lt; n; i++) &#123; if (s[i] == &#x27;W&#x27;) &#123; for (ll j = i + 1; j &lt; n; j++) &#123; if (s[j] == &#x27;H&#x27;) &#123; for (ll k = j + 1; k &lt; n; k++) &#123; if (s[k] == &#x27;U&#x27;) cnt[3]++; &#125; &#125; &#125; &#125; &#125; if (cnt[0] == max(&#123;cnt[0], cnt[1], cnt[2], cnt[3], cnt[4]&#125;)) &#123; cout &lt;&lt; &quot;CCNU &quot; &lt;&lt; cnt[0] &lt;&lt; &#x27;\\n&#x27;; &#125;else if (cnt[1] == max(&#123;cnt[0], cnt[1], cnt[2], cnt[3], cnt[4]&#125;)) &#123; if (cnt[0] == cnt[1]) &#123; cout &lt;&lt; &quot;CCNU &quot; &lt;&lt; cnt[0] &lt;&lt; &#x27;\\n&#x27;; &#125;else &#123; cout &lt;&lt; &quot;HUST &quot; &lt;&lt; cnt[1] &lt;&lt; &#x27;\\n&#x27;; &#125; &#125;else if (cnt[2] == max(&#123;cnt[0], cnt[1], cnt[2], cnt[3], cnt[4]&#125;)) &#123; if (cnt[0] == cnt[2]) &#123; cout &lt;&lt; &quot;CCNU &quot; &lt;&lt; cnt[0] &lt;&lt; &#x27;\\n&#x27;; &#125;else if (cnt[1] == cnt[2]) &#123; cout &lt;&lt; &quot;HUST &quot; &lt;&lt; cnt[1] &lt;&lt; &#x27;\\n&#x27;; &#125;else &#123; cout &lt;&lt; &quot;HZAU &quot; &lt;&lt; cnt[2] &lt;&lt; &#x27;\\n&#x27;; &#125; &#125;else if (cnt[3] == max(&#123;cnt[0], cnt[1], cnt[2], cnt[3], cnt[4]&#125;)) &#123; if (cnt[0] == cnt[3]) &#123; cout &lt;&lt; &quot;CCNU &quot; &lt;&lt; cnt[0] &lt;&lt; &#x27;\\n&#x27;; &#125;else if (cnt[1] == cnt[3]) &#123; cout &lt;&lt; &quot;HUST &quot; &lt;&lt; cnt[1] &lt;&lt; &#x27;\\n&#x27;; &#125;else if (cnt[2] == cnt[3]) &#123; cout &lt;&lt; &quot;HZAU &quot; &lt;&lt; cnt[2] &lt;&lt; &#x27;\\n&#x27;; &#125;else &#123; cout &lt;&lt; &quot;WHU &quot; &lt;&lt; cnt[3] &lt;&lt; &#x27;\\n&#x27;; &#125; &#125;else if (cnt[4] == max(&#123;cnt[0], cnt[1], cnt[2], cnt[3], cnt[4]&#125;)) &#123; if (cnt[0] == cnt[4]) &#123; cout &lt;&lt; &quot;CCNU &quot; &lt;&lt; cnt[0] &lt;&lt; &#x27;\\n&#x27;; &#125;else if (cnt[1] == cnt[4]) &#123; cout &lt;&lt; &quot;HUST &quot; &lt;&lt; cnt[1] &lt;&lt; &#x27;\\n&#x27;; &#125;else if (cnt[2] == cnt[4]) &#123; cout &lt;&lt; &quot;HZAU &quot; &lt;&lt; cnt[2] &lt;&lt; &#x27;\\n&#x27;; &#125;else if (cnt[3] == cnt[4]) &#123; cout &lt;&lt; &quot;WHU &quot; &lt;&lt; cnt[3] &lt;&lt; &#x27;\\n&#x27;; &#125;else &#123; cout &lt;&lt; &quot;WHUT &quot; &lt;&lt; cnt[4] &lt;&lt; &#x27;\\n&#x27;; &#125; &#125;&#125;int main ()&#123; ios::sync_with_stdio(0); cin.tie(0); int _ = 1; // cin &gt;&gt; _; while (_--) &#123; solve(); &#125; return 0;&#125; B - 易守难攻题意：给定一个空的 n 行 m 列的网格，需要往每一个格子填入一个$1$ ~ $n\\times m$的高度值，满足有 k 个网格的高度值严格大于 8 个相邻格子的高度值，且这 k 个网格不位于边界上。输出满足条件的网格，或者报告不存在这样的分配方式。 思路：首先明确：将大数一个隔一个的放是最大化能放置网格的放置方法。手模几个样例可以发现，若$(n - 1) &#x2F; 2 \\times (m - 1) &#x2F; 2 &lt; k$，则放不下满足条件的 k 个网格。我们可以从最大数开始放置。先将大数一个隔一个数地放，保证大数之间不会互相干扰。再依次放置其他数即可，可以保证大数总是可以满足条件的，且其他数不会形成新的满足条件的网格。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;using ld = long double;using pi = pair&lt;ll, ll&gt;;#define fi first#define se secondconst int MAXN = 6e7;const double eps = 1e-5;const ll mod = 1e9 + 7;void solve ()&#123; ll n, m, k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; if (((n - 1) / 2) * ((m - 1) / 2) &lt; k) &#123; cout &lt;&lt; &quot;No&quot; &lt;&lt; &#x27;\\n&#x27;; return; &#125; vector &lt;vector &lt;ll&gt; &gt; v(n + 1, vector &lt;ll&gt; (m + 1)); vector &lt;vector &lt;bool&gt; &gt; vis(n + 1, vector &lt;bool&gt; (m + 1, false)); ll t = n * m; if (k != 0) &#123; ll cnt = 0; bool found = true; for (int i = 2; i &lt; n; i += 2) &#123; for (int j = 2; j &lt; m; j += 2) &#123; cnt++; v[i][j] = t--; vis[i][j] = true; if (cnt == k) found = false; if (!found) break; &#125; if (!found) break; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; if (vis[i][j]) continue; v[i][j] = t--; &#125; &#125; cout &lt;&lt; &quot;Yes&quot; &lt;&lt; &#x27;\\n&#x27;; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; cout &lt;&lt; v[i][j] &lt;&lt; &#x27; &#x27;; &#125; cout &lt;&lt; &#x27;\\n&#x27;; &#125;&#125;int main ()&#123; ios::sync_with_stdio(0); cin.tie(0); int _ = 1; cin &gt;&gt; _; while (_--) &#123; solve(); &#125; return 0;&#125; F - Anon 的疑问题意：询问$q$次$(1 \\leq q \\leq 1e6)$，每次询问给定一个正整数$n(1 \\leq n \\leq 2e7)$，判断其能否被分解为两个正整数的平方和。 思路：这里给出两种思路。 第一种思路：首先可以观察到这里的数据量并不是很大，我们完全可以直接预处理平方在$2e7$内的数，然后枚举得到所有满足条件的正整数。时间复杂度:$O(2e7)$。 第二种思路：可以利用两平方和定理：对于任意的正整数$n &#x3D; a^2 + b^2(a, b \\in Z)$，当且仅当在 n 的质因数分解中，所有形如$p \\equiv 3 (mod 4)$的质数，其指数都是偶数。根据定理，我们可以先预处理出在$2e7$内所有数的最小质因数，然后再根据每个数判断其指数奇偶性。 但是这里由于询问次数可能很多，时间复杂度相对于暴力可能没有优势，且无法通过本题，仅供参考。 时间复杂度：$O(q\\times nlogn)$。 代码：思路一：123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;using ld = long double;using pi = pair&lt;ll, ll&gt;;#define fi first#define se secondconst int MAXN = 6e7;const double eps = 1e-5;const ll mod = 1e9 + 7;bool vis[20000005];//这里如果用vector记录可能会被卡常void solve ()&#123; ll n; cin &gt;&gt; n; if (vis[n]) &#123; cout &lt;&lt; &quot;Yes&quot; &lt;&lt; &#x27;\\n&#x27;; &#125;else &#123; cout &lt;&lt; &quot;No&quot; &lt;&lt; &#x27;\\n&#x27;; &#125;&#125;int main ()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; cin &gt;&gt; _; for (int i = 1; i &lt; 4473; i++) &#123; if (i * i &gt; 2e7 + 2) break; for (int j = i; j &lt; 4473; j++) &#123; if (i * i + j * j &gt; 2e7 + 2) break; vis[i * i + j * j] = true; &#125; &#125; while (_--) &#123; solve(); &#125; return 0;&#125; 思路二：（仅供参考）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;using ld = long double;using pi = pair&lt;ll, ll&gt;;#define fi first#define se secondconst int N = 2e7 + 1;const double eps = 1e-5;const ll mod = 1e9 + 7;bool isprime[N];int prime[N], mnp[N];ll cnt = 0;void get_mn_prime_factor ()&#123; mnp[1] = 1; for (int i = 2; i &lt; N; i++) &#123; if (!isprime[i]) &#123; prime[cnt++] = i; mnp[i] = i; &#125; for (int j = 0; j &lt; cnt &amp;&amp; i * prime[j] &lt; N; j++) &#123; isprime[i * prime[j]] = true; mnp[i * prime[j]] = prime[j]; if (i % prime[j] == 0) break; &#125; &#125;&#125;void solve ()&#123; ll n; cin &gt;&gt; n; auto check = [&amp;] (int x) -&gt; bool &#123; ll t = x; while (t != 1) &#123; ll p = mnp[t]; ll cnt = 0; while (t % p == 0) &#123; t /= p; cnt++; &#125; if (p % 4 == 3 &amp;&amp; cnt &amp; 1) &#123; return false; &#125; &#125; if ((ll)sqrtl(x) * (ll)sqrtl(x) == x) return false;//特判 else return true; &#125;; cout &lt;&lt; (check(n) ? &quot;Yes&quot; : &quot;No&quot;) &lt;&lt; &#x27;\\n&#x27;;&#125;int main ()&#123; ios::sync_with_stdio(0); cin.tie(0); int _ = 1; cin &gt;&gt; _; get_mn_prime_factor(); while (_--) &#123; solve(); &#125; return 0;&#125; G - 你好，世界题意：有一个初始值为 0 的 N 位计数器，用来预测一条指令是否应当执行。 当扫描到一条指令时，若计数器的值小于$2^{N - 1}$，则预测该指令将不被执行，否则预测将被执行。 无论是否预测正确，如果当前指令的真实状况为需要执行，则计数器增加 1，否则计数器减少 1。 计数器的增加和减少不会超过$[0,2^N)$这一界限。 你需要构造一个长度为 len 的 01 字符串（指令），0 代表不执行，1 代表执行，使得预测错误的次数最大。 思路：诈骗题。理解题意后，不难发现只需要使前$2^{N - 1}$个指令执行，后面的指令只需不执行，执行(01 循环)即可。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;using ld = long double;using pi = pair&lt;ll, ll&gt;;#define fi first#define se secondconst int MAXN = 6e7;const double eps = 1e-5;const ll mod = 1e9 + 7;ll qpow (ll a, ll b)&#123; ll res = 1; while (b) &#123; if (b &amp; 1) res = res * a; a = a * a; b &gt;&gt;= 1; &#125; return res;&#125;void solve ()&#123; ll n, len; cin &gt;&gt; n &gt;&gt; len; ll tag = len; if (n &lt;= 60) tag = min(qpow(2, n - 1), len); for (int i = 0; i &lt; tag; i++) &#123; cout &lt;&lt; 1; &#125; for (int i = 0; i &lt; len - tag; i++) &#123; cout &lt;&lt; (i &amp; 1); &#125;&#125;int main ()&#123; ios::sync_with_stdio(0); cin.tie(0); int _ = 1; // cin &gt;&gt; _; while (_--) &#123; solve(); &#125; return 0;&#125; H - 哆啦 A 梦的神奇铜锣烧储存系统题意：有$n$个宝箱，其中有$k$个宝箱里装有铜锣烧，哆啦 A 梦先从中选择$m$个他认为最有可能装有铜锣烧的宝箱，然后在剩下的$n - m$个宝箱中随机打开$n - (m + q)$个空箱子（若没有空箱子则不打开），最后剩下$q$个宝箱是关闭的。求出剩下的未打开$q$个宝箱中铜锣烧的期望数量（模 998244353）。 思路：简洁的思路是：我们考虑任意一个真箱子，在每一次选完$m$个后，这个箱子仍然存在于$n - m$个箱子的期望为$E[X_i] &#x3D; \\frac{n - m}{n}$。一共有$k$个真箱子，只需要将$k$个期望累加就能得出答案：$\\frac{n - m}{n} \\times k$。 详细过程：（鸣谢笔者ichooooooo！） 首先，这是一道超几何分布题 经典场景：总共有$N$个商品，其中$M$个特殊品，选取$n$个出来 求$n$个商品中特殊商品期望设$X$是$n$个商品里的特殊品数量 $E &#x3D; \\sum_{X &#x3D; 0}^{M}(X \\times P(X))$ 这里$P(X)$是从$n$个中抽取$X$个特殊品的概率， $X \\times P(X)$ 是抽到$i$个特殊元素时，特殊品数量的期望贡献，$(n - X) \\times P(X)$ 则是抽到$i$个特殊元素时，非特殊品数量的期望贡献 求$P(X)$超几何分布知识，我们用$\\binom{k}{i}$表示$C(i, k)$，最终公式$$\\frac{\\binom{M}{X}\\binom{N - M}{n - X}}{\\binom{N}{n}}$$其中$\\binom{M}{X}$表示从$X$个总特殊品选取$M$个，那么剩下$n - X$个是非特殊，再从$N - M$个总非特殊选取$n - X$个，相乘是“有利情况”，除总情况就是概率 期望化简后求和结果$$\\frac{M}{N} \\times n$$ 回到题目，根据上面我们最终需要得到抽 n 个商品时，非特殊商品的期望，即$${\\sum_{i &#x3D; 0}^{min(k, m)}(k - i)} \\times P(i)$$展开得$$\\frac{\\sum_{i &#x3D; 0}^{min(k, m)}\\binom{k}{i}\\binom{n - k}{m - i}(k - i)}{\\binom{n}{m}}$$化简得$$\\frac{n - m}{n} \\times k$$ 关于为什么 q 不会影响到最终结果 q 只抽取空箱子，不影响特殊品的数量，根据公式，P(i)不变，权值 k - i 也不变，所以结果不变 代码：原始公式:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;using ld = long double;using pi = pair&lt;ll, ll&gt;;#define fi first#define se secondconst int MAXN = 1e6 + 10;const double eps = 1e-5;const ll mod = 998244353;vector &lt;ll&gt; f(MAXN), g(MAXN);ll qpow (ll a, ll b)&#123; ll res = 1; while (b) &#123; if (b &amp; 1) res = res * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return res % mod;&#125;ll C (ll n, ll m)&#123; if (m &lt; 0 || m &gt; n) return 0; return f[n] * g[m] % mod * g[n - m] % mod;&#125;void solve ()&#123; ll n, k, m, q; cin &gt;&gt; n &gt;&gt; k &gt;&gt; m &gt;&gt; q; ll a = 0, b = 0; for (int i = 0; i &lt;= min(k, m); i++) &#123; a = (a + C(k, i) * C(n - k, m - i) % mod * (k - i) % mod) % mod; &#125; b = C(n, m); ll ans = a * qpow(b, mod - 2) % mod; cout &lt;&lt; ans &lt;&lt; &#x27;\\n&#x27;;&#125;int main ()&#123; ios::sync_with_stdio(0); cin.tie(0); int _ = 1; // cin &gt;&gt; _; f[0] = 1, g[0] = 1; for (int i = 1; i &lt; MAXN; i++) &#123; f[i] = f[i - 1] * i % mod; g[i] = qpow(f[i], mod - 2) % mod; &#125; while (_--) &#123; solve(); &#125; return 0;&#125; 化简：1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;using ld = long double;using pi = pair&lt;ll, ll&gt;;#define fi first#define se secondconst int MAXN = 6e7;const double eps = 1e-5;const ll mod = 998244353;ll qpow (ll a, ll b)&#123; ll res = 1; while (b) &#123; if (b &amp; 1) res = res * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return res % mod;&#125;void solve ()&#123; ll n, k, m, q; cin &gt;&gt; n &gt;&gt; k &gt;&gt; m &gt;&gt; q; cout &lt;&lt; (n - m) * k % mod * qpow(n, mod - 2) % mod &lt;&lt; &#x27;\\n&#x27;;&#125;int main ()&#123; ios::sync_with_stdio(0); cin.tie(0); int _ = 1; // cin &gt;&gt; _; while (_--) &#123; solve(); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://everlastingblog.top/categories/%E9%A2%98%E8%A7%A3/"},{"name":"游记","slug":"游记","permalink":"https://everlastingblog.top/categories/%E6%B8%B8%E8%AE%B0/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://everlastingblog.top/tags/%E9%A2%98%E8%A7%A3/"},{"name":"游记","slug":"游记","permalink":"https://everlastingblog.top/tags/%E6%B8%B8%E8%AE%B0/"}]},{"title":"2025菜鸟杯部分题解","slug":"2025_WUST_CNB","date":"2025-12-14T16:00:00.000Z","updated":"2026-01-13T11:41:10.489Z","comments":true,"path":"2025/12/15/2025_WUST_CNB/","permalink":"https://everlastingblog.top/2025/12/15/2025_WUST_CNB/","excerpt":"A - hello题意：第一行输出“HELL0 WUSTACM!”，第二行输出“maintain integrity,think diligently, and challenge yourself”。","text":"A - hello题意：第一行输出“HELL0 WUSTACM!”，第二行输出“maintain integrity,think diligently, and challenge yourself”。 代码：12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;using ld = long double;#define fi first#define se secondconst ll MAXN = 1e7;const ld eps = 1e-12;const ll mod = 1e9 + 7;ll n;void solve ()&#123; cout &lt;&lt; &quot;HELL0 WUSTACM!&quot; &lt;&lt; &#x27;\\n&#x27;; cout &lt;&lt; &quot;maintain integrity,think diligently, and challenge yourself&quot; &lt;&lt; &#x27;\\n&#x27;;&#125;int main ()&#123; ios::sync_with_stdio(0); cin.tie(0); int _ = 1; // cin &gt;&gt; _; while (_--) &#123; solve(); &#125; return 0;&#125; C - 杨弟的电梯题意：输入一个整数 n 和 0 或 1，0 代表夏天，1 代表冬天。夏天时人数不少于 10 人输出 hot，不到 10 人输出 cool。冬天时人数不少于 10 人输出 warm，不到 10 人输出 cold。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;using ld = long double;#define fi first#define se secondconst ll MAXN = 1e7;const ld eps = 1e-12;const ll mod = 1e9 + 7;ll n, a;void solve ()&#123; cin &gt;&gt; n &gt;&gt; a; if (n &gt; 15) &#123; cout &lt;&lt; &quot;error&quot; &lt;&lt; &#x27;\\n&#x27;; return; &#125; if (a == 0) &#123; if (n &lt; 10) &#123; cout &lt;&lt; &quot;cool&quot; &lt;&lt; &#x27;\\n&#x27;; &#125;else &#123; cout &lt;&lt; &quot;hot&quot; &lt;&lt; &#x27;\\n&#x27;; &#125; &#125;else &#123; if (n &lt; 10) &#123; cout &lt;&lt; &quot;cold&quot; &lt;&lt; &#x27;\\n&#x27;; &#125;else &#123; cout &lt;&lt; &quot;warm&quot; &lt;&lt; &#x27;\\n&#x27;; &#125; &#125;&#125;int main ()&#123; ios::sync_with_stdio(0); cin.tie(0); int _ = 1; // cin &gt;&gt; _; while (_--) &#123; solve(); &#125; return 0;&#125; F - 猫猫题意：根据程序输出，程序如下： 1234567miao_func(x): miaomiao (x &lt; 1) miaomiaomiaowu 0 miaomiaomiao (x &amp; 1) miaomiaomiaowu x + miao_func(x - 2) miaomiaomioa miaomiaomiaowu miao_func(x - 2) - x 喵语：miaomiao : ifmiaomiaomiao : else ifmiaomiaomioa : elsemiaomiaomiaowu : return 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;using ld = long double;#define fi first#define se secondconst ll MAXN = 1e7;const ld eps = 1e-12;const ll mod = 1e9 + 7;ll n;void solve ()&#123; cin &gt;&gt; n; auto func = [&amp;] (ll x, auto self) -&gt; ll &#123; if (x &lt; 1) &#123; return 0; &#125;else if (x &amp; 1) &#123; return x + self(x - 2, self); &#125;else &#123; return self(x - 2, self) - x; &#125; &#125;; ll ans = func(n, func); cout &lt;&lt; ans &lt;&lt; &#x27;\\n&#x27;;&#125;int main ()&#123; ios::sync_with_stdio(0); cin.tie(0); int _ = 1; // cin &gt;&gt; _; while (_--) &#123; solve(); &#125; return 0;&#125; D - 装糖果题意：给定 n 种类型的糖果，k 和每种类型糖果的数量，求至少买多少个袋子能满足以下限制条件： 每个袋子最多能装下 k 个糖果 每个袋子中同一种类的糖果至多只能有一个 思路：贪心。考虑最后的袋子有两种可能，一种是包含多种糖果，一种是只有一种糖果。对于第一种情况，至少的袋子数量即为 ceil(sum &#x2F; k),对于第二种情况，至少的袋子数量即为最大的糖果数量。两种情况取最大值即可。时间复杂度：O(n)。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;using ld = long double;#define fi first#define se secondconst ll MAXN = 1e7;const ld eps = 1e-12;const ll mod = 1e9 + 7;ll n, k;void solve ()&#123; cin &gt;&gt; n &gt;&gt; k; vector &lt;ll&gt; v(n + 1); ll mx = 0; ll sum = 0; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; v[i]; sum += v[i]; mx = max(mx, v[i]); &#125; ll t; if (sum % k == 0) &#123; t = sum / k; &#125;else &#123; t = sum / k + 1; &#125; cout &lt;&lt; max(t, mx);&#125;int main ()&#123; ios::sync_with_stdio(0); cin.tie(0); int _ = 1; // cin &gt;&gt; _; while (_--) &#123; solve(); &#125; return 0;&#125; G - 礼包和 scandi题意：给定碗的数量和每个碗中的米饭量。scandi 要吃完所有米饭且想要米饭量尽量少，礼包想要 scandi 吃的米饭量尽量多。在开始吃饭前，两人可以轮流对米饭量进行调整，礼包先手，过程如下： 任选一个满足 ai !&#x3D; ai+1的 i。 将 ai变为 func(ai，ai+1)。 当无法找到满足要求的 i 时，调整环节结束。注意：对于 scandi 而言，func() &#x3D; min()，对于礼包而言，func() &#x3D; max()。 求最终 scandi 需要吃掉的米饭总量 思路：诈骗题。手模样例后发现，当所有数等于最后一个数时才不会满足题意。直接输出即可。时间复杂度：O(n)。 代码：123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;using ld = long double;#define fi first#define se secondconst ll MAXN = 1e7;const ld eps = 1e-12;const ll mod = 1e9 + 7;ll n;void solve ()&#123; cin &gt;&gt; n; vector &lt;ll&gt; v(n + 1, 0); for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; v[i]; &#125; cout &lt;&lt; v[n] * n &lt;&lt; &#x27;\\n&#x27;;&#125;int main ()&#123; ios::sync_with_stdio(0); cin.tie(0); int _ = 1; // cin &gt;&gt; _; while (_--) &#123; solve(); &#125; return 0;&#125; H - 凡安要当超级农民题意：给定矩阵的长和宽为 n 和 m，并给定次数 q。接下来的 q 行中，给定魔法生效点座标，延伸长度和魔法效果。魔法效果：在生效点上，上下左右依次延伸 k 个点，使得每个点的产量增加 s(初始产量为 0)。求最终矩阵中每个点的产量。 思路：数据量不大，模拟即可。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;using ld = long double;#define fi first#define se secondconst ll MAXN = 1e7;const ld eps = 1e-12;const ll mod = 1e9 + 7;ll n, m, q;void solve ()&#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; q; vector &lt;vector &lt;ll&gt; &gt; v(n + 1, vector &lt;ll&gt; (m + 1, 0)); while (q--) &#123; ll x, y, k, s; cin &gt;&gt; x &gt;&gt; y &gt;&gt; k &gt;&gt; s; v[x][y] += s; for (int i = x - k; i &lt;= x + k; i++) &#123; if (i == x) continue; ll xx = (i + n - 1) % n + 1; v[xx][y] += s; &#125; for (int i = y - k; i &lt;= y + k; i++) &#123; if (i == y) continue; ll yy = (i + m - 1) % m + 1; v[x][yy] += s; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; cout &lt;&lt; v[i][j] &lt;&lt; &#x27; &#x27;; &#125; cout &lt;&lt; &#x27;\\n&#x27;; &#125;&#125;int main ()&#123; ios::sync_with_stdio(0); cin.tie(0); int _ = 1; // cin &gt;&gt; _; while (_--) &#123; solve(); &#125; return 0;&#125; L - 逃课计划题意：一周七天，每天有六节课，给定老师的具体查课时间，即第几天第几节。在两天不能逃同一节课的情况下，求出可能的逃课计划数量。 思路：最大可能不超过 3e5 种情况，因此直接暴力 dfs 即可。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;using ld = long double;using pi = pair&lt;ll, ll&gt;;#define fi first#define se secondconst ll MAXN = 1e7;const ld eps = 1e-12;const ll mod = 1e9 + 7;vector &lt;vector &lt;ll&gt; &gt; e(8);ll n;ll ans = 0;void solve ()&#123; cin &gt;&gt; n; map &lt;pair&lt;ll, ll&gt;, bool&gt; mp; for (int i = 0; i &lt; n; i++) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; mp[&#123;a, b&#125;] = true; &#125; for (int i = 1; i &lt;= 7; i++) &#123; for (int j = 1; j &lt;= 6; j++) &#123; if (!mp[&#123;i, j&#125;]) &#123; e[i].push_back(j); &#125; &#125; &#125; auto dfs = [&amp;] (ll day, ll course, auto self) -&gt; void &#123; if (day == 7) &#123; ans++; return; &#125; for (auto x : e[day + 1]) &#123; if (x == course) continue; self(day + 1, x, self); &#125; &#125;; for (auto x : e[1]) &#123; dfs(1, x, dfs); &#125; cout &lt;&lt; ans &lt;&lt; &#x27;\\n&#x27;;&#125;int main ()&#123; ios::sync_with_stdio(0); cin.tie(0); int _ = 1; // cin &gt;&gt; _; while (_--) &#123; solve(); &#125; return 0;&#125; E - 比较 A 和 B 的大小题意：给定一种新的比较两数大小的方式：整数部分相同，但小数部分按整数来比较大小。例如：0.13 &gt; 0.3, 0.50 &gt; 0.5。给定两个数，若新的方式与数学方式的比大小结果相同，输出”ni shi dui de”否则，输出”ni cuo le, ying gai shi ‘正确答案’”。 “正确答案”为：&lt;, &gt;, &#x3D;。 思路：首先注意到若存在一个数是整数，两种比大小的结果一定相同。接下来先判断整数部分，若整数部分不同，比大小结果一定也相同。若相同再来比较小数部分。小数部分中，分别将其根据数学方法和新的方式比较（注意前导 0 和后导 0 的讨论），查看两者结果是否不同即可。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;using ld = long double;using pi = pair&lt;ll, ll&gt;;#define fi first#define se secondconst int MAXN = 6e7;const double eps = 1e-5;const ll mod = 998244353;string a1, a2;void solve ()&#123; cin &gt;&gt; a1 &gt;&gt; a2; if (a1.find(&#x27;.&#x27;) == string::npos || a2.find(&#x27;.&#x27;) == string::npos) &#123; cout &lt;&lt; &quot;ni shi dui de&quot; &lt;&lt; &#x27;\\n&#x27;; return; &#125; string s1 = a1.substr(0, a1.find(&#x27;.&#x27;)); string s2 = a2.substr(0, a2.find(&#x27;.&#x27;)); if (s1 != s2) &#123; cout &lt;&lt; &quot;ni shi dui de&quot; &lt;&lt; &#x27;\\n&#x27;; return; &#125; string ss1 = a1.substr(a1.find(&#x27;.&#x27;) + 1); string ss2 = a2.substr(a2.find(&#x27;.&#x27;) + 1); int found2 = 0;//normal compare for (int i = 0; i &lt; min(ss1.size(), ss2.size()); i++) &#123; if (ss1[i] &lt; ss2[i]) &#123; found2 = 1; break; &#125;else if (ss1[i] &gt; ss2[i]) &#123; found2 = 2; break; &#125; &#125; if (found2 == 0) &#123; if (ss1.size() &lt; ss2.size()) &#123; bool foundd = false; for (int i = ss1.size(); i &lt; ss2.size(); i++) &#123; if (ss2[i] != &#x27;0&#x27;) &#123; foundd = true; &#125; &#125; if (foundd) &#123; found2 = 1; &#125; &#125;else if (ss1.size() &gt; ss2.size()) &#123; bool foundd = false; for (int i = ss2.size(); i &lt; ss1.size(); i++) &#123; if (ss1[i] != &#x27;0&#x27;) &#123; foundd = true; &#125; &#125; if (foundd) &#123; found2 = 2; &#125; &#125; &#125; int found3 = 0;//require compare string t1; int index = 0;//remove 0 from front while (index &lt; ss1.size()) &#123; if (ss1[index] != &#x27;0&#x27;) &#123; break; &#125; index++; &#125; t1 = ss1.substr(index, ss1.size() - index); string t2; index = 0; while (index &lt; ss2.size()) &#123; if (ss2[index] != &#x27;0&#x27;) &#123; break; &#125; index++; &#125; t2 = ss2.substr(index, ss2.size() - index); if (t1.size() &lt; t2.size()) &#123; found3 = 1; &#125;else if (t1.size() &gt; t2.size()) &#123; found3 = 2; &#125;else &#123; for (int i = 0; i &lt; t1.size(); i++) &#123; if (t1[i] &lt; t2[i]) &#123; found3 = 1; break; &#125;else if (t1[i] &gt; t2[i]) &#123; found3 = 2; break; &#125; &#125; &#125; if (found2 == found3) &#123; cout &lt;&lt; &quot;ni shi dui de&quot; &lt;&lt; &#x27;\\n&#x27;; &#125;else if (found2 == 0 &amp;&amp; found3 == 1) &#123; cout &lt;&lt; &quot;ni cuo le, ying gai shi &lt;&quot; &lt;&lt; &#x27;\\n&#x27;; &#125;else if (found2 == 0 &amp;&amp; found3 == 2) &#123; cout &lt;&lt; &quot;ni cuo le, ying gai shi &gt;&quot; &lt;&lt; &#x27;\\n&#x27;; &#125;else if (found2 == 1 &amp;&amp; found3 == 0) &#123; cout &lt;&lt; &quot;ni cuo le, ying gai shi =&quot; &lt;&lt; &#x27;\\n&#x27;; &#125;else if (found2 == 1 &amp;&amp; found3 == 2) &#123; cout &lt;&lt; &quot;ni cuo le, ying gai shi &gt;&quot; &lt;&lt; &#x27;\\n&#x27;; &#125;else if (found2 == 2 &amp;&amp; found3 == 0) &#123; cout &lt;&lt; &quot;ni cuo le, ying gai shi =&quot; &lt;&lt; &#x27;\\n&#x27;; &#125;else if (found2 == 2 &amp;&amp; found3 == 1) &#123; cout &lt;&lt; &quot;ni cuo le, ying gai shi &lt;&quot; &lt;&lt; &#x27;\\n&#x27;; &#125;&#125;int main ()&#123; ios::sync_with_stdio(0); cin.tie(0); int _ = 1; //cin &gt;&gt; _; while (_--) &#123; solve(); &#125; return 0;&#125; K - 小白的好数组题意：给定一个长度为 n 的数组，求至少需要进行多少次对一个数加 p 的操作，可以使得数组至少有 k 个数字相同。 思路:首先可以知道，若两个数%p 的结果相同，则两个数之间一定可以通过+p 的形式边成一个数。若不同，则一定不行。因此，可以根据此条件分成 p 个组，在每一组中排完序后，可能的最小的答案一定是连续的。因此，只需要以滑动窗口的形式来寻找答案即可。时间复杂度：O(n)。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;using ld = long double;using pi = pair&lt;ll, ll&gt;;#define fi first#define se secondconst int MAXN = 6e7;const double eps = 1e-5;const ll mod = 998244353;ll n, k, p;void solve ()&#123; cin &gt;&gt; n &gt;&gt; k &gt;&gt; p; vector &lt;vector &lt;ll&gt; &gt; a(p); for (int i = 0; i &lt; n; i++) &#123; ll t; cin &gt;&gt; t; a[t % p].push_back(t); &#125; bool found = false; ll ans = LLONG_MAX; for (int i = 0; i &lt; p; i++) &#123; if (a[i].size() &lt; k) continue; else found = true; sort(a[i].begin(), a[i].end()); ll mn = 0; for (int j = 0; j &lt; k - 1; j++) &#123; mn += (a[i][k - 1] - a[i][j]) / p; &#125; ans = min(ans, mn); ll l = 1, r = k; while (r &lt; a[i].size()) &#123; mn -= (a[i][r - 1] - a[i][l - 1]) / p; mn += (a[i][r] - a[i][r - 1]) / p * (k - 1); ans = min(mn, ans); l++; r++; &#125; &#125; if (!found) &#123; cout &lt;&lt; &quot;wuwuwu&quot; &lt;&lt; &#x27;\\n&#x27;; &#125;else &#123; cout &lt;&lt; ans &lt;&lt; &#x27;\\n&#x27;; &#125;&#125;int main ()&#123; ios::sync_with_stdio(0); cin.tie(0); int _ = 1; //cin &gt;&gt; _; while (_--) &#123; solve(); &#125; return 0;&#125; B - 小李吃豆子题意：给定一个在 1e12 内的 n，求有多少个连续的数列相加后等于 n。 思路：对于任意 n，假设其连续数列为 p，p + 1, p + 2,…, p + k - 1。对其求和后即可得到：(2p + k - 1) * k &#x2F; 2 &#x3D; n。化简后即为：p &#x3D; (2n &#x2F; k - k + 1) &#x2F; 2。即一个符合要求的 p，一定会满足以下两个条件： 2n % k &#x3D;&#x3D; 0 (2n &#x2F; k - k + 1) % 2 &#x3D;&#x3D; 0 因为范围为 1e12，考虑优化。2n &#x2F; k - k + 1 &gt;&#x3D; 0 的条件为 p &gt;&#x3D; sqrt(2n)，即只需遍历 sqrt(2n)内的数即可。时间复杂度：O(sqrt(2n))。 代码：123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;using ld = long double;#define fi first#define se secondconst ll MAXN = 1e7;const ld eps = 1e-12;const ll mod = 1e9 + 7;ll n;void solve ()&#123; cin &gt;&gt; n; ll m = sqrtl(2 * n); ll ans = 0; for (int i = 1; i &lt;= m; i++) &#123; if ((2 * n) % i == 0 &amp;&amp; ((2 * n) / i - i + 1) % 2 == 0) &#123; ans++; &#125; &#125; cout &lt;&lt; ans &lt;&lt; &#x27;\\n&#x27;;&#125;int main ()&#123; ios::sync_with_stdio(0); cin.tie(0); int _ = 1; // cin &gt;&gt; _; while (_--) &#123; solve(); &#125; return 0;&#125; I - 攻守兼备题意：给定 n 张卡牌，每张卡牌有攻击力和防御值。想要从这 n 张卡牌中找到两张卡，使得这两张卡的总攻击力和总防御力的最小值达到最大，输出总攻击力和总防御力的最小值的最大值。 思路：这里采用贪心做法。具体思路见wustacm 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;using ld = long double;using pi = pair&lt;ll, ll&gt;;#define fi first#define se secondconst ll MAXN = 1e7;const ld eps = 1e-12;const ll mod = 1e9 + 7;ll n;void solve ()&#123; cin &gt;&gt; n; vector &lt;pi&gt; v(n); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; v[i].fi &gt;&gt; v[i].se; &#125; sort(v.begin(), v.end(), [] (auto a1, auto b1) &#123; return abs(a1.fi - a1.se) &lt; abs(b1.fi - b1.se); &#125;); ll ans = 0, maxfi = 0, maxse = 0; for (int i = 0; i &lt; n; i++) &#123; if (v[i].fi &gt; v[i].se) &#123; ans = max(ans, maxse + v[i].se); &#125;else &#123; ans = max(ans, maxfi + v[i].fi); &#125; maxfi = max(maxfi, v[i].fi); maxse = max(maxse, v[i].se); &#125; cout &lt;&lt; ans &lt;&lt; &#x27;\\n&#x27;;&#125;int main ()&#123; ios::sync_with_stdio(0); cin.tie(0); int _ = 1; // cin &gt;&gt; _; while (_--) &#123; solve(); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://everlastingblog.top/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://everlastingblog.top/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"华中农业大学第十五届程序设计竞赛（新生赛）游记及部分题解","slug":"2025_HZAU_Freshman_contest","date":"2025-12-08T16:00:00.000Z","updated":"2026-01-13T11:41:39.638Z","comments":true,"path":"2025/12/09/2025_HZAU_Freshman_contest/","permalink":"https://everlastingblog.top/2025/12/09/2025_HZAU_Freshman_contest/","excerpt":"仅以此记录我的第一次程序设计线下赛","text":"仅以此记录我的第一次程序设计线下赛 游记第一次线下赛，不出意料的感觉晚上没睡好，但到了比赛场地后就毫无疲惫感而言了。（瑞幸的新品是真难喝） 到场签到领了伴手礼，一个ACM的笔记本和一张明信片，虽然有点不及预期，但第一次拿到周边物件还是很兴奋的。在这里还是得感谢志愿者，赛前领的小纸条一下就弄丢了，上面的帐号密码志愿者们很热情地帮我解决了，非常感谢！另外赛前统一发的小熊猫dev还是很好用的，避免了用电脑自带的devc++，好评！ 比赛开始后，很幸运地快速发现了签到题L，拿了一个一血！交完显示“correct”的时候发现自己是一血还是非常兴奋的！之后看了眼D题，发现跟热身赛的题差不多一样（其实并非），写完wa了之后，看到榜上有不少人也wa了D，就觉得有点不对劲了，仔细看题发现只能删除长度大于一的字串，找了下规律后又交了一发，wa了之后就没碰D题了(赛后题解显示是一道恐怖的分类讨论)。 接下来值得说的就是C题，赛时看出来是单调栈很兴奋，快速敲完交了一发wa后，由于没读清题意，自己一直在那乱改，交了无数发，最后十分钟实在没招了，而且此时也对题目思考地比较深入，再把第一发wa去掉特判后交了一发竟然A了(真的感受到了救赎感)，但是白白在这道题浪费了一个多小时，赛后看来很有可能可以再开一题，也是很可惜了。 另外，赛中发的午饭是一个“冷”热狗，鸡腿和两根香肠，难吃。 最后还是凭借7题获得了金牌，但以993的罚时在7题尾。就本次比赛来说，一定要想清楚题目再交，下次不能 “样例过了就AC” 了。 部分题解L - 山海之约题意：给定两个非负整数 a 与 b，判断它们的和是否为神秘数字 350234。 代码：12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;using ld = long double;#define fi first#define se secondconst ll MAXN = 1e8;const ld eps = 1e-12;const ll mod = 1e9 + 7;void solve ()&#123; ll a, b; cin &gt;&gt; a &gt;&gt; b; if (a + b == 350234) &#123; cout &lt;&lt; &quot;YES&quot; &lt;&lt; &#x27;\\n&#x27;; &#125;else &#123; cout &lt;&lt; &quot;NO&quot; &lt;&lt; &#x27;\\n&#x27;; &#125;&#125;int main ()&#123; ios::sync_with_stdio(0); cin.tie(0); int _ = 1; cin &gt;&gt; _; while (_--) &#123; solve(); &#125; return 0;&#125; H - 对决题意：给定两个字符串 s 与 t，记字串“fire”出现次数是a，“water”出现次数是b， “wind”出现次数是c，定义字符串的权值为a + b * c，判断s的权值是否严格大于t的权值。 思路：简单遍历即可。时间复杂度：O(n + m)。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;using ld = long double;#define fi first#define se secondconst ll MAXN = 1e8;const ld eps = 1e-12;const ll mod = 1e9 + 7;ll n, m;void solve ()&#123; string a = &quot;fire&quot;; string b = &quot;water&quot;; string c = &quot;wind&quot;; cin &gt;&gt; n &gt;&gt; m; string s, t; cin &gt;&gt; s &gt;&gt; t; ll cnta = 0; ll cntb = 0; ll cntc = 0; for (int i = 0; i &lt;= n - 4; i++) &#123; if (s[i] == &#x27;f&#x27; &amp;&amp; s[i + 1] == &#x27;i&#x27; &amp;&amp; s[i + 2] == &#x27;r&#x27; &amp;&amp; s[i + 3] == &#x27;e&#x27;) &#123; cnta++; &#125; if (s[i] == &#x27;w&#x27; &amp;&amp; s[i + 1] == &#x27;i&#x27; &amp;&amp; s[i + 2] == &#x27;n&#x27; &amp;&amp; s[i + 3] == &#x27;d&#x27;) &#123; cntc++; &#125; &#125; for (int i = 0; i &lt;= n - 5; i++) &#123; if (s[i] == &#x27;w&#x27; &amp;&amp; s[i + 1] == &#x27;a&#x27; &amp;&amp; s[i + 2] == &#x27;t&#x27; &amp;&amp; s[i + 3] == &#x27;e&#x27; &amp;&amp; s[i + 4] == &#x27;r&#x27;) &#123; cntb++; &#125; &#125; ll cntaa = 0; ll cntbb = 0; ll cntcc = 0; for (int i = 0; i &lt;= m - 4; i++) &#123; if (t[i] == &#x27;f&#x27; &amp;&amp; t[i + 1] == &#x27;i&#x27; &amp;&amp; t[i + 2] == &#x27;r&#x27; &amp;&amp; t[i + 3] == &#x27;e&#x27;) &#123; cntaa++; &#125; if (t[i] == &#x27;w&#x27; &amp;&amp; t[i + 1] == &#x27;i&#x27; &amp;&amp; t[i + 2] == &#x27;n&#x27; &amp;&amp; t[i + 3] == &#x27;d&#x27;) &#123; cntcc++; &#125; &#125; for (int i = 0; i &lt;= m - 5; i++) &#123; if (t[i] == &#x27;w&#x27; &amp;&amp; t[i + 1] == &#x27;a&#x27; &amp;&amp; t[i + 2] == &#x27;t&#x27; &amp;&amp; t[i + 3] == &#x27;e&#x27; &amp;&amp; t[i + 4] == &#x27;r&#x27;) &#123; cntbb++; &#125; &#125; if (cnta + cntb * cntc &gt; cntaa + cntbb * cntcc) &#123; cout &lt;&lt; &quot;YES&quot; &lt;&lt; &#x27;\\n&#x27;; &#125;else &#123; cout &lt;&lt; &quot;NO&quot; &lt;&lt; &#x27;\\n&#x27;; &#125;&#125;int main ()&#123; ios::sync_with_stdio(0); cin.tie(0); int _ = 1; cin &gt;&gt; _; while (_--) &#123; solve(); &#125; return 0;&#125; I - 学霸题题意给定三个点 A, B, C，找出一个点D使得这 4 个点可以连成一个平行四边形。 思路确定两个点，求出两点间x和y座标的变化后根据第三个点推出第四个点的位置。时间复杂度：O(1)。 代码12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;using ld = long double;#define fi first#define se secondconst ll MAXN = 1e8;const ld eps = 1e-12;const ll mod = 1e9 + 7;void solve ()&#123; ll x1, y1, x2, y2, x3, y3; cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; x3 &gt;&gt; y3; ll tx = x2 - x1; ll ty = y2 - y1; ll x4 = x3 + tx; ll y4 = y3 + ty; cout &lt;&lt; x4 &lt;&lt; &#x27; &#x27; &lt;&lt; y4 &lt;&lt; &#x27;\\n&#x27;;&#125;int main ()&#123; ios::sync_with_stdio(0); cin.tie(0); int _ = 1; cin &gt;&gt; _; while (_--) &#123; solve(); &#125; return 0;&#125; B - 爱的魔法题意给定一个序列，对于序列中的每一个数，交换至多两个数位，最大化操作后的序列和。 思路数据范围不是很大，直接对每一个数简单遍历，取每个数的最大值即可。时间复杂度：O(n)。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;using ld = long double;#define fi first#define se secondconst ll MAXN = 1e8;const ld eps = 1e-12;const ll mod = 1e9 + 7;ll n;void solve ()&#123; cin &gt;&gt; n; vector &lt;ll&gt; v(n); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; v[i]; &#125; for (int i = 0; i &lt; n; i++) &#123; string s = to_string(v[i]); for (int k = 0; k &lt; (ll)s.size(); k++) &#123; ll t = s[k] - &#x27;0&#x27;; ll pos = k; for (ll j = k + 1; j &lt; (ll)s.size(); j++) &#123; ll a = s[j] - &#x27;0&#x27;; if (a &gt;= t) &#123; t = a; pos = j; &#125; &#125; if (pos != k &amp;&amp; s[pos] &gt; s[k]) &#123; swap(s[pos], s[k]); break; &#125; &#125; v[i] = stoll(s); &#125; ll ans = 0; for (int i = 0; i &lt; n; i++) &#123; ans += v[i]; &#125; cout &lt;&lt; ans &lt;&lt; &#x27;\\n&#x27;;&#125;int main ()&#123; ios::sync_with_stdio(0); cin.tie(0); int _ = 1; cin &gt;&gt; _; while (_--) &#123; solve(); &#125; return 0;&#125; A - 矩形游戏题意给定一个单调不降的序列[b1, b2, … bn]与一个k行n列的矩阵A。签到哥从矩阵的第一行第一列移动到第k行的任意一列。签到哥位于(i, j)时可以移动到(i + 1, j - 1)或(i + 1, j)或(i + 1, j + 1)。签到哥只能移动到大于等于自己的位置，且移动后签到哥的体力也会相应增加。 求签到哥到达第k行的体力最大值 思路由于序列单调不降，只需尽量往右走就行。另外，由于k是1e9级别，而n是2e5级别，最后如果到最后一列可以直接退出单独计算。时间复杂度：O(n)。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;using ld = long double;#define fi first#define se secondconst ll MAXN = 1e8;const ld eps = 1e-12;const ll mod = 1e9 + 7;ll k, n;void solve ()&#123; cin &gt;&gt; k &gt;&gt; n; vector &lt;ll&gt; v(n); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; v[i]; &#125; ll sum = 0; ll j = 0; ll t = 0; for (int i = 0; i &lt; k; i++) &#123; if (sum &gt;= v[j + 1] &amp;&amp; j &lt; n - 1) &#123; j++; &#125; sum += v[j]; if (j == n - 1) &#123; t = k - i - 1; break; &#125; &#125; sum += max(0LL, t) * v[n - 1]; cout &lt;&lt; sum &lt;&lt; &#x27;\\n&#x27;;&#125;int main ()&#123; ios::sync_with_stdio(0); cin.tie(0); int _ = 1; cin &gt;&gt; _; while (_--) &#123; solve(); &#125; return 0;&#125; M - 终极考验题意给定n个石柱高度，耗费一点能量可以使任意一个i至min(i + x - 1, n)区间内的所有石柱升高1米。 求使得石柱的高度单调不降所要耗费能量的最小值。 思路这里给出一个另类的思路。对于任意一个vi，在（i - x + 1， i）这个区间内若存在vy需要增加，则vi一定会与vy增加相同次数。因此，在维护好一个差分数组后，我们可以考虑对于任意一个di，加上需要做区间加且区间加触及不到di的合法的di - x，最后加上所有小于0的d[i]的绝对值即可时间复杂度：O(n); 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;using ld = long double;#define fi first#define se secondconst ll MAXN = 1e8;const ld eps = 1e-12;const ll mod = 1e9 + 7;void solve ()&#123; ll n, x; cin &gt;&gt; n &gt;&gt; x; vector &lt;ll&gt; v(n + 1, 0); vector &lt;ll&gt; d(n + 1, 0); for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; v[i]; d[i] = v[i] - v[i - 1]; &#125; for (int i = x + 1; i &lt;= n; i++) &#123; if (d[i - x] &lt; 0) &#123; d[i] += d[i - x]; &#125; &#125; ll ans = 0; for (int i = 2; i &lt;= n; i++) &#123; if (d[i] &lt; 0) &#123; ans += abs(d[i]); &#125; &#125; cout &lt;&lt; ans &lt;&lt; &#x27;\\n&#x27;; &#125;int main ()&#123; ios::sync_with_stdio(0); cin.tie(0); int _ = 1; cin &gt;&gt; _; while (_--) &#123; solve(); &#125; return 0;&#125; C - 小W的计数题题意对于给出的每一个ai，找到元素数量最多的集合Sx, 其中对于任意的y∈S，使得[amin{x,y}, …, amax{x,y}]的最大值为ay。 思路题意很复杂，简要地说，这一题实际上是想要找到对于每一个ai向左的单调递增区间和向右的单调递增区间的长度之和。由此，不难想到可以利用单调栈来解决问题。可以维护从前往后的一个单调递减栈和从后往前的维护一个单调递减栈，在每一位加上栈的大小，重复两遍即是最终结果。时间复杂度：O(n)。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;using ld = long double;#define fi first#define se secondconst ll MAXN = 1e8;const ld eps = 1e-12;const ll mod = 1e9 + 7;ll n;void solve ()&#123; cin &gt;&gt; n; vector &lt;ll&gt; v(n + 1); for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; v[i]; &#125; vector &lt;ll&gt; ans(n + 1, 0); stack &lt;ll&gt; stk; for (int i = 1; i &lt;= n; i++) &#123; while (!stk.empty() &amp;&amp; v[i] &gt; stk.top()) &#123; stk.pop(); &#125; stk.push(v[i]); ans[i] += stk.size(); &#125; stack &lt;ll&gt; stk1; for (int i = n; i &gt;= 1; i--) &#123; while (!stk1.empty() &amp;&amp; v[i] &gt; stk1.top()) &#123; stk1.pop(); &#125; stk1.push(v[i]); ans[i] += stk1.size(); &#125; for (int i = 1; i &lt;= n; i++) &#123; cout &lt;&lt; ans[i] - 1 &lt;&lt; &#x27; &#x27;; &#125; cout &lt;&lt; &#x27;\\n&#x27;; &#125;int main ()&#123; ios::sync_with_stdio(0); cin.tie(0); int _ = 1; cin &gt;&gt; _; while (_--) &#123; solve(); &#125; return 0;&#125; G - 二分图判定题意给定一个序列[a1, a2, … an]和一个正整数k, 在一张包含n个点的图上，第i个点的权值为i，对于合法的任意两点i，j，若 |ai - aj| &gt; k，就在i与j两点之间连接一条无向边。 求出最小的非负整数k，使得按照上述方法生成的图是二分图。 思路读完题后不难发现，该题的目的是在给定的an序列中，将其分为两个集合，并最小化两个集合的极差的最大值。 不难想到可以利用二分答案的方法来解决这道题, 可以先对an序列进行排序，再以答案进行从前到后和从后到前的check，最后若r &lt;&#x3D; l + 1则说明check成功。时间复杂度：O(nlogn)。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;using ld = long double;#define fi first#define se secondconst ll MAXN = 1e8;const ld eps = 1e-12;const ll mod = 998244353;ll n;void solve ()&#123; cin &gt;&gt; n; vector &lt;ll&gt; v(n + 1); for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; v[i]; &#125; sort(v.begin() + 1, v.end()); auto check = [&amp;] (ll md) -&gt; bool &#123; ll l = 1; for (int i = 1; i &lt;= n; i++) &#123; if (v[i] - v[1] &lt;= md) &#123; l = i; &#125;else &#123; break; &#125; &#125; ll r = n; for (int i = n - 1; i &gt;= 1; i--) &#123; if (v[n] - v[i] &lt;= md) &#123; r = i; &#125;else &#123; break; &#125; &#125; return r &lt;= l + 1; &#125;; ll l = 0, r = v[n]; while (l &lt;= r) &#123; ll mid = l + ((r - l) &gt;&gt; 1); if (check(mid)) &#123; r = mid - 1; &#125;else &#123; l = mid + 1; &#125; &#125; cout &lt;&lt; l &lt;&lt; &#x27;\\n&#x27;;&#125;int main ()&#123; ios::sync_with_stdio(0); cin.tie(0); int _ = 1; cin &gt;&gt; _; while (_--) &#123; solve(); &#125; return 0;&#125; J - 鱼骨挖矿法题意给定一个n行m列的二位网格，每个格子的数字代表当前格的矿物价值。首先钒钒会选择第i行作为主矿道，并将主矿道上方和下方的矿道的所有矿物全部采集。再以主矿道为中心，在每个满足j &#x3D;&#x3D;&#x3D; 2 (mod 3)的j列（分矿道）分别向上向下挖，在挖到第一个矿物时停止挖掘。 挖掘规则： 如果在一次挖掘操作中发现多个矿物，钒钒会将这些矿物同时挖掘。 如果在当前分矿道上挖掘到矿物，钒钒会立即停止挖掘 上下分矿道的挖掘情况相互独立，即：上分矿道的挖掘情况不会影响到下分矿道的挖掘情况。 求在以第i行为主矿道时(1 &lt;&#x3D; i &lt;&#x3D; n)， 所能挖到的矿物的总价值。 思路首先，对于每一个主矿道来说，我们可以预处理每一个主矿道的结果。而对于每一个分矿道来说，对于向上的分矿道，我们可以预处理出到每一格时所能挖到的矿物价值，即sup[i][j] &#x3D; v[i][j] + v[i - 1][j] + v[i][j - 1] + v[i][j + 1]。若sup[i][j] !&#x3D; 0，则up[i][j] &#x3D; sup[i][j]，否则up[i][j] &#x3D; up[i - 1][j]。向下的分矿道也是类似的。在每个i行，只需要加上所有合法的up[i - 2][j]和dw[i + 2][j]即可。时间复杂度：O(n * m)。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;using ld = long double;#define fi first#define se secondconst ll MAXN = 1e8;const ld eps = 1e-12;const ll mod = 1e9 + 7;ll n, m;void solve ()&#123; cin &gt;&gt; n &gt;&gt; m; vector &lt;vector &lt;ll&gt; &gt; v(n + 3, vector &lt;ll&gt; (m + 3)); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; cin &gt;&gt; v[i][j]; &#125; &#125; vector &lt;ll&gt; ss(n + 2, 0); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; ss[i] += v[i][j]; &#125; &#125; vector &lt;ll&gt; s(n + 2, 0);//主矿道 for (int i = 1; i &lt;= n; i++) &#123; s[i] = ss[i - 1] + ss[i] + ss[i + 1]; &#125; vector &lt;vector &lt;ll&gt; &gt; sa(n + 2, vector &lt;ll&gt; (m + 2));//上部分矿道 for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; sa[i][j] = v[i][j] + v[i - 1][j] + v[i][j - 1] + v[i][j + 1]; &#125; &#125; vector &lt;vector &lt;ll&gt; &gt; up(n + 2, vector &lt;ll&gt; (m + 2)); for (int j = 1; j &lt;= m; j++) &#123; for (int i = 1; i &lt;= n; i++) &#123; if (sa[i][j] != 0) &#123; up[i][j] = sa[i][j]; &#125;else &#123; up[i][j] = up[i - 1][j]; &#125; &#125; &#125; vector &lt;vector &lt;ll&gt; &gt; sb(n + 2, vector &lt;ll&gt; (m + 2));//下部分矿道 for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; sb[i][j] = v[i][j] + v[i + 1][j] + v[i][j - 1] + v[i][j + 1]; &#125; &#125; vector &lt;vector &lt;ll&gt; &gt; dw(n + 2, vector &lt;ll&gt; (m + 2)); for (int j = 1; j &lt;= m; j++) &#123; for (int i = n; i &gt;= 1; i--) &#123; if (sb[i][j] != 0) &#123; dw[i][j] = sb[i][j]; &#125;else &#123; dw[i][j] = dw[i + 1][j]; &#125; &#125; &#125; vector &lt;ll&gt; ans(n + 1, 0); for (int i = 1; i &lt;= n; i++) &#123; if (i == 1) &#123; ans[i] += s[i]; if (n &lt;= 2) continue; for (int j = 2; j &lt;= m; j += 3) &#123; ans[i] += dw[i + 2][j]; &#125; &#125;else if (i == n) &#123; ans[i] += s[n]; if (n &lt;= 2) continue; for (int j = 2; j &lt;= m; j += 3) &#123; ans[i] += up[i - 2][j]; &#125; &#125;else &#123; ans[i] += s[i]; if (n &lt;= 2) continue; for (int j = 2; j &lt;= m; j += 3) &#123; ans[i] += up[i - 2][j] + dw[i + 2][j]; &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; cout &lt;&lt; ans[i] &lt;&lt; &#x27; &#x27;; &#125; cout &lt;&lt; &#x27;\\n&#x27;;&#125;int main ()&#123; ios::sync_with_stdio(0); cin.tie(0); int _ = 1; cin &gt;&gt; _; while (_--) &#123; solve(); &#125; return 0;&#125; K - 大师和他的领域题意给定一个数组a和值k，求有多少个区间满足以下要求： 区间中必须包含值k 区间中大于k值的数量必须等于小于k值的数量 思路我们可以令大于k的值为1，小于k的值为-1，等于k的值为0。维护一个前缀和数组。对于每一个的下标，都往前二分查找相同值且包含值k的最大左边界即可。时间复杂度：O(nlogn)。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;using ld = long double;#define fi first#define se secondconst ll MAXN = 1e8;const ld eps = 1e-12;const ll mod = 998244353;ll n, k;string s;void solve ()&#123; cin &gt;&gt; n &gt;&gt; k; vector &lt;ll&gt; v(n + 1); for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; v[i]; &#125; vector &lt;ll&gt; s(n + 1, 0); for (int i = 1; i &lt;= n; i++) &#123; s[i] = s[i - 1]; if (v[i] &gt; k) &#123; s[i]++; &#125;else if (v[i] &lt; k) &#123; s[i]--; &#125; &#125; vector &lt;vector&lt;ll&gt; &gt; pos(2 * n + 2); pos[n].push_back(0); ll ans = 0; ll exist = -1; for (int i = 1; i &lt;= n; i++) &#123; pos[s[i] + n].push_back(i); if (v[i] == k) &#123; exist = i; &#125; if (exist != -1) &#123; ans += lower_bound(pos[s[i] + n].begin(), pos[s[i] + n].end(), exist) - pos[s[i] + n].begin(); &#125; &#125; cout &lt;&lt; ans &lt;&lt; &#x27;\\n&#x27;;&#125;int main ()&#123; ios::sync_with_stdio(0); cin.tie(0); int _ = 1; cin &gt;&gt; _; while (_--) &#123; solve(); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://everlastingblog.top/categories/%E9%A2%98%E8%A7%A3/"},{"name":"游记","slug":"游记","permalink":"https://everlastingblog.top/categories/%E6%B8%B8%E8%AE%B0/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://everlastingblog.top/tags/%E9%A2%98%E8%A7%A3/"},{"name":"游记","slug":"游记","permalink":"https://everlastingblog.top/tags/%E6%B8%B8%E8%AE%B0/"}]}],"categories":[{"name":"题解","slug":"题解","permalink":"https://everlastingblog.top/categories/%E9%A2%98%E8%A7%A3/"},{"name":"答案","slug":"答案","permalink":"https://everlastingblog.top/categories/%E7%AD%94%E6%A1%88/"},{"name":"游记","slug":"游记","permalink":"https://everlastingblog.top/categories/%E6%B8%B8%E8%AE%B0/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://everlastingblog.top/tags/%E9%A2%98%E8%A7%A3/"},{"name":"答案","slug":"答案","permalink":"https://everlastingblog.top/tags/%E7%AD%94%E6%A1%88/"},{"name":"游记","slug":"游记","permalink":"https://everlastingblog.top/tags/%E6%B8%B8%E8%AE%B0/"}]}